{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ChatFlow","text":""},{"location":"#introduction","title":"Introduction","text":"<p>ChatFlow is a domain-specific language designed specifically for authoring conversational dialog flows, such as for chatbots and voice assistants. </p> <p>It provides an easy to read and write syntax that models natural conversations, with abstractions for common constructs needed for conversational interfaces. ChatFlow makes it simpler for non-programmers to define complex conversational experiences.</p> <p>The language can integrate tightly with Python enabling advanced functionality when required through custom code. ChatFlow aims to balance simplicity with versatility. </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Readability: ChatFlow syntax reads like natural language to enable non-programmers to understand and author dialog flows.</p> </li> <li> <p>Easy to use: The specialized DSL provides high-level abstractions tailored for conversations like dialog flows, conditional logic, variables, etc. making chatbot development intuitive.</p> </li> <li> <p>Integration: ChatFlow provides rich integration capabilities with external systems via Python. It allows data processing in real-time during the conversation. Users can define custom execution flows named \"tributary\", which enable integration with anything in Python including databases, APIs and more.</p> </li> <li> <p>Integration with python's async functionality: ChatFlow enables asynchronous, non-blocking execution of dialogs via Python's async/await model. This allows I/O operations like API calls to run in parallel without blocking during a conversation.  </p> </li> <li> <p>Interpreted: ChatFlow scripts are interpreted at runtime, enabling rapid prototyping. The interpreter provides early detection of errors in conversational logic during testing without needing compilation.</p> </li> <li> <p>Extensible: Users can extend ChatFlow functionality by calling out to Python code within dialog scripts. This allows adding advanced or custom processing logic when needed.</p> </li> </ul>"},{"location":"#learning-chatflow","title":"Learning ChatFlow","text":"<ol> <li>Quick Start</li> <li>Tutorial</li> <li>Grammar</li> </ol>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>ChatFlow owes much gratitude to the open source projects that helped make it possible.</p> <p>In particular:</p> <ul> <li>Lark     ChatFlow builds on the excellent Lark parsing toolkit for generating the abstract syntax tree from the Conversation Flow scripts. The ability to define a clean grammar and easily parse it into a manipulatable tree structure is invaluable.</li> </ul>"},{"location":"#license","title":"License","text":"<p>Lark uses the MIT license.</p>"},{"location":"BNF/","title":"BNF Definition of ChatFlow","text":"<p>Following is the BNF definition of ChatFlow:</p> <pre><code>&lt;chatflow&gt; ::= &lt;flow&gt;+\n\n&lt;flow&gt; ::= \"flow\" &lt;flow_name&gt; \"{\" &lt;block&gt; \"}\"\n\n&lt;block&gt; ::= &lt;statement&gt;*\n\n&lt;statement&gt; ::= &lt;if_statement&gt;\n              | &lt;speak_statement&gt;  \n              | &lt;engage_statement&gt;\n              | &lt;handover_statement&gt;\n              | &lt;end_statement&gt;\n              | &lt;listen_statement&gt;\n              | &lt;assign_statement&gt;\n              | &lt;while_statement&gt;  \n              | &lt;store_statement&gt;\n              | &lt;fetch_statement&gt;\n              | \"{\" &lt;block&gt; \"}\"\n\n&lt;store_statement&gt; ::= \"store\" &lt;value&gt;\n\n&lt;fetch_statement&gt; ::= \"fetch\" &lt;variable&gt;\n\n&lt;if_statement&gt; ::= \"if\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\" &lt;else_statement&gt;?\n\n&lt;else_statement&gt; ::= \"else\" \"{\" &lt;block&gt; \"}\"\n                  | \"else\" &lt;if_statement&gt;\n\n&lt;while_statement&gt; ::= \"while\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\"\n\n&lt;speak_statement&gt; ::= \"speak\" &lt;str_expression&gt;  \n\n&lt;str_expression&gt; ::= &lt;value&gt; (\"+\" &lt;value&gt;)*\n\n&lt;engage_statement&gt; ::= \"engage\" &lt;flow_name&gt;\n\n&lt;handover_statement&gt; ::= \"handover\" &lt;tributary_name&gt;  \n\n&lt;end_statement&gt; ::= \"end\"\n\n&lt;listen_statement&gt; ::= \"listen\" \"for\" &lt;variable&gt; (\"for\" &lt;time&gt;)?\n\n&lt;assign_statement&gt; ::= \"assign\" &lt;expression&gt; \"to\" &lt;variable&gt;\n\n&lt;condition&gt; ::= &lt;match_compare&gt; \n              | &lt;equal_compare&gt;\n              | &lt;larger_compare&gt; \n              | &lt;less_compare&gt;\n              | &lt;boolean&gt;\n              | &lt;timeout&gt;\n              | \"not\" &lt;condition&gt;\n\n&lt;larger_compare&gt; ::= &lt;expression&gt; \"larger\" \"than\" &lt;expression&gt;  \n\n&lt;less_compare&gt; ::= &lt;expression&gt; \"less\" \"than\" &lt;expression&gt;\n\n&lt;boolean&gt; ::= TRUE | FALSE\n\nTRUE ::= \"true\"  \n\nFALSE ::= \"false\"\n\n&lt;match_compare&gt; ::= &lt;expression&gt; \"match\" &lt;value&gt; (\"as\" &lt;variable&gt;)?\n\n&lt;equal_compare&gt; ::= &lt;expression&gt; \"equals\" &lt;expression&gt;\n\n&lt;expression&gt; ::= &lt;term&gt; (&lt;add_sub_operator&gt; &lt;term&gt;)*\n\n&lt;term&gt; ::= &lt;factor&gt; (&lt;mul_div_operator&gt; &lt;factor&gt;)*  \n\n&lt;factor&gt; ::= &lt;value&gt;\n           | \"(\" &lt;expression&gt; \")\"\n\n&lt;add_sub_operator&gt; ::= PLUS | MINUS\n\n&lt;mul_div_operator&gt; ::= TIMES | DIVIDE   \n\nTIMES ::= \"*\"  \n\nDIVIDE ::= \"/\"\n\nPLUS ::= \"+\"  \n\nMINUS ::= \"-\"\n\n&lt;value&gt; ::= &lt;timeout&gt;  \n          | &lt;literal&gt;\n          | &lt;variable&gt;   \n\n&lt;variable&gt; ::= &lt;identifier&gt;  \n\n&lt;identifier&gt; ::= IDENTIFIER\n\n&lt;flow_name&gt; ::= &lt;identifier&gt;\n\n&lt;tributary_name&gt; ::= &lt;identifier&gt; \n\n&lt;time&gt; ::= &lt;value&gt; &lt;time_unit&gt;  \n\n&lt;time_unit&gt; ::= SECOND | MINUTE | HOUR\n\nSECOND ::= \"s\"  \n\nMINUTE ::= \"m\"\n\nHOUR ::= \"h\"\n\n&lt;timeout&gt; ::= \"timeout\"\n\n&lt;literal&gt; ::= STRING  \n           | NUMBER\n\nIDENTIFIER ::= letter(letter | digit | \"_\")*\nletter ::= \"A\"..\"Z\" | \"a\"..\"z\"\ndigit ::= \"0\"..\"9\"  \n</code></pre>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright \u00a9 2023 65456u</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"async/","title":"Async Support","text":"<p>ChatFlow supports async mode in Python out of the box. To enable asynchronous execution of ChatFlow programs, you just need to use <code>Runtime.arun()</code> instead of <code>Runtime.run()</code>. </p> <p>For example, the following synchronous program:</p> <pre><code>def main():\n    interpreter = Interpreter(code=code)\n    runtime = Runtime(interpreter)\n    runtime.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>can be easily tranformed into asynchronous mode:</p> <pre><code>async def main():\n    interpreter = Interpreter(code=code) \n    runtime = Runtime(interpreter, async_flag=True)\n    await runtime.arun()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>You can also define your custom async speak and listen functions as well as async tributaries.</p> <p>In summary, ChatFlow enables:</p> <ul> <li>Async mode with simple Runtime swap</li> <li>Custom async speak, listen and tributaries</li> <li>Asynchronous, non-blocking execution</li> </ul>"},{"location":"context/","title":"Context","text":""},{"location":"context/#chatflow.context.Context","title":"<code>Context</code>","text":"<p>Context for a ChatFlow Flow</p> <p>This class represents the context for a ChatFlow flow. It stores information such as the flow's parameter, return value, scope, tree, and timeout status. It also provides methods for manipulating the scope and accessing variables within the scope.</p> Source code in <code>chatflow\\context.py</code> <pre><code>class Context:\n    \"\"\"Context for a ChatFlow Flow\n\n    This class represents the context for a ChatFlow flow. It stores information such as the flow's parameter,\n    return value, scope, tree, and timeout status. It also provides methods for manipulating the scope and accessing\n    variables within the scope.\n    \"\"\"\n\n    def __init__(self, parameter, tree):\n        \"\"\"\n        The constructor for the Context class.\n\n        Args:\n            parameter (any): The parameter used to passed to and from other flows.\n            tree (lark.Tree): The tree representing the ChatFlow Flow.\n        \"\"\"\n        self.parameter = parameter\n        self.return_value = None\n        self.scope = list()\n        self.scope_count = 0\n        self.tree = tree\n        self.timeout = False\n\n    def push_scope(self):\n        \"\"\"\n        Pushes a new scope onto the stack.\n\n        This method appends an empty dictionary to the `scope` list and increments the `scope_count` variable.\n\n        \"\"\"\n        self.scope.append(dict())\n        self.scope_count += 1\n\n    def pop_scope(self):\n        \"\"\"\n        Pops the topmost scope from the context.\n\n        This method removes the topmost scope from the context's scope stack.\n\n        \"\"\"\n        self.scope.pop()\n        self.scope_count -= 1\n\n    def get_variable(self, name):\n        for i in range(self.scope_count - 1, -1, -1):\n            if name in self.scope[i]:\n                return self.scope[i][name]\n        raise NameError(f\"Name '{name}' is not defined\")\n\n    def set_variable(self, name, value):\n        for i in range(self.scope_count - 1, -1, -1):\n            if name in self.scope[i]:\n                self.scope[i][name] = value\n                return False\n        self.scope[self.scope_count - 1][name] = value\n        return True\n\n    def get_parameter(self):\n        return self.parameter\n\n    def set_timeout(self, timeout: bool):\n        self.timeout = timeout\n\n    def __repr__(self):\n        return str(self.scope)\n\n    def set_parameter(self, parameter):\n        self.parameter = parameter\n</code></pre>"},{"location":"context/#chatflow.context.Context.__init__","title":"<code>__init__(parameter, tree)</code>","text":"<p>The constructor for the Context class.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>any</code> <p>The parameter used to passed to and from other flows.</p> required <code>tree</code> <code>Tree</code> <p>The tree representing the ChatFlow Flow.</p> required Source code in <code>chatflow\\context.py</code> <pre><code>def __init__(self, parameter, tree):\n    \"\"\"\n    The constructor for the Context class.\n\n    Args:\n        parameter (any): The parameter used to passed to and from other flows.\n        tree (lark.Tree): The tree representing the ChatFlow Flow.\n    \"\"\"\n    self.parameter = parameter\n    self.return_value = None\n    self.scope = list()\n    self.scope_count = 0\n    self.tree = tree\n    self.timeout = False\n</code></pre>"},{"location":"context/#chatflow.context.Context.pop_scope","title":"<code>pop_scope()</code>","text":"<p>Pops the topmost scope from the context.</p> <p>This method removes the topmost scope from the context's scope stack.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def pop_scope(self):\n    \"\"\"\n    Pops the topmost scope from the context.\n\n    This method removes the topmost scope from the context's scope stack.\n\n    \"\"\"\n    self.scope.pop()\n    self.scope_count -= 1\n</code></pre>"},{"location":"context/#chatflow.context.Context.push_scope","title":"<code>push_scope()</code>","text":"<p>Pushes a new scope onto the stack.</p> <p>This method appends an empty dictionary to the <code>scope</code> list and increments the <code>scope_count</code> variable.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def push_scope(self):\n    \"\"\"\n    Pushes a new scope onto the stack.\n\n    This method appends an empty dictionary to the `scope` list and increments the `scope_count` variable.\n\n    \"\"\"\n    self.scope.append(dict())\n    self.scope_count += 1\n</code></pre>"},{"location":"executors/","title":"Executors","text":"<p>Executors for running different types of statements.</p>"},{"location":"executors/#chatflow.executors.getters.compare.get_condition","title":"<code>get_condition(condition, context)</code>","text":"<p>Get the value of a condition based on its type.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>The condition node.</p> required <code>context</code> <code>Context</code> <p>The context dictionary.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>The value of the condition.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_condition(condition, context):\n    \"\"\"\n    Get the value of a condition based on its type.\n\n    Args:\n        condition (lark.Tree): The condition node.\n        context (Context): The context dictionary.\n\n    Returns:\n        result (bool): The value of the condition.\n\n    \"\"\"\n    condition = condition.children[0]\n    condition_type = condition.data\n    match condition_type:\n        case \"match_compare\":\n            return get_match_compare(condition, context)\n        case \"equal_compare\":\n            return get_equal_compare(condition, context)\n        case \"larger_compare\":\n            return get_larger_compare(condition, context)\n        case \"less_compare\":\n            return get_less_compare(condition, context)\n        case \"timeout\":\n            return context.timeout\n        case \"boolean\":\n            return get_boolean(condition)\n        case \"condition\":\n            return not get_condition(condition, context)\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_equal_compare","title":"<code>get_equal_compare(condition, context)</code>","text":"<p>Get the equal compare result.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>The condition to be compared.</p> required <code>context</code> <code>Context</code> <p>The context in which the comparison is performed.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the first value is equal to the second value, False otherwise.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_equal_compare(condition, context):\n    \"\"\"Get the equal compare result.\n\n    Args:\n        condition (lark.Tree): The condition to be compared.\n        context (Context): The context in which the comparison is performed.\n\n    Returns:\n        result (bool): True if the first value is equal to the second value, False otherwise.\n    \"\"\"\n    first_expression = condition.children[0]\n    second_expression = condition.children[1]\n    first_value = get_expression(first_expression, context)\n    second_value = get_expression(second_expression, context)\n    return first_value == second_value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_larger_compare","title":"<code>get_larger_compare(condition, context)</code>","text":"<p>Get the larger compare result.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>the condition object</p> required <code>context</code> <code>Context</code> <p>the context object</p> required <p>Returns:     bool: the result of the compare</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_larger_compare(condition, context):\n    \"\"\"Get the larger compare result.\n\n    Args:\n        condition (lark.Tree): the condition object\n        context (Context): the context object\n    Returns:\n        bool: the result of the compare\n    \"\"\"\n    first_expression = condition.children[0]\n    second_expression = condition.children[1]\n    first_value = get_expression(first_expression, context)\n    second_value = get_expression(second_expression, context)\n    return first_value &gt; second_value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_less_compare","title":"<code>get_less_compare(condition, context)</code>","text":"<p>Compare two values and return True if the first value is less than the second value.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Expression</code> <p>The condition to evaluate.</p> required <code>context</code> <code>Context</code> <p>The context in which the condition is evaluated.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the first value is less than the second value, False otherwise.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_less_compare(condition, context):\n    \"\"\"\n    Compare two values and return True if the first value is less than the second value.\n\n    Args:\n        condition (Expression): The condition to evaluate.\n        context (Context): The context in which the condition is evaluated.\n\n    Returns:\n        result (bool): True if the first value is less than the second value, False otherwise.\n    \"\"\"\n    first_expression = condition.children[0]\n    second_expression = condition.children[1]\n    first_value = get_expression(first_expression, context)\n    second_value = get_expression(second_expression, context)\n    return first_value &lt; second_value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_match_compare","title":"<code>get_match_compare(condition, context)</code>","text":"<p>Get the match compare result.</p> <p>This function takes a condition and a context as input and performs a match compare operation. It checks if the expression matches the value using regular expressions.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>The condition object containing the expression, value, and optional variable.</p> required <code>context</code> <code>Context</code> <p>The context object containing the variables.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the expression or value is not a string.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the expression matches the value, False otherwise.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_match_compare(condition, context):\n    \"\"\"Get the match compare result.\n\n    This function takes a condition and a context as input and performs a match compare operation.\n    It checks if the expression matches the value using regular expressions.\n\n    Args:\n        condition (lark.Tree): The condition object containing the expression, value, and optional variable.\n        context (Context): The context object containing the variables.\n\n    Raises:\n        Exception: If the expression or value is not a string.\n\n    Returns:\n        result (bool): True if the expression matches the value, False otherwise.\n    \"\"\"\n    expression = condition.children[0]\n    expression = get_expression(expression, context)\n    value = condition.children[1]\n    value = get_value(value, context)\n    if type(expression) is not str or type(value) is not str:\n        raise Exception(\"Match compare only supports string values\")\n    if len(condition.children) == 2:\n        return re.match(value, expression)\n    else:\n        variable = condition.children[2]\n        variable = get_variable_name(variable)\n        result = re.search(value, expression)\n        if result:\n            context.set_variable(variable, result.group())\n            return True\n        else:\n            context.set_variable(variable, None)\n            return False\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_expression","title":"<code>get_expression(expression, context)</code>","text":"<p>Get the value of an expression. This function takes an expression and a context as input and returns the value of the expression. Args:     expression (lark.Tree): The expression to evaluate.     context (Context): The context in which the expression is evaluated. Returns:     Any: The value of the expression.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_expression(expression, context):\n    \"\"\"Get the value of an expression.\n    This function takes an expression and a context as input and returns the value of the expression.\n    Args:\n        expression (lark.Tree): The expression to evaluate.\n        context (Context): The context in which the expression is evaluated.\n    Returns:\n        Any: The value of the expression.\n    \"\"\"\n    term = expression.children[0]\n    value = get_term(term, context)\n    for i in range(1, len(expression.children), 2):\n        operator = expression.children[i].children[0]\n        term = expression.children[i + 1]\n        term_value = get_term(term, context)\n        if operator.type == \"PLUS\":\n            value += term_value\n        elif operator.type == \"MINUS\":\n            value -= term_value\n    return value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_factor","title":"<code>get_factor(factor, context)</code>","text":"<p>Get the value of a factor. This function takes a factor and a context as input and returns the value of the factor. Args:     factor (lark.Tree): The factor to evaluate.     context (Context): The context in which the factor is evaluated. Returns:     Any: The value of the factor.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_factor(factor, context):\n    \"\"\"Get the value of a factor.\n    This function takes a factor and a context as input and returns the value of the factor.\n    Args:\n        factor (lark.Tree): The factor to evaluate.\n        context (Context): The context in which the factor is evaluated.\n    Returns:\n        Any: The value of the factor.\n    \"\"\"\n    factor = factor.children[0]\n    if factor.data == \"value\":\n        result = get_value(factor, context)\n    else:\n        result = get_expression(factor, context)\n    return result\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_str_expression","title":"<code>get_str_expression(expression, context)</code>","text":"<p>Get the string representation of an expression.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Tree</code> <p>The expression to evaluate.</p> required <code>context</code> <code>Context</code> <p>The context in which the expression is evaluated.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>str</code> <p>The string representation of the evaluated expression.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_str_expression(expression, context):\n    \"\"\"Get the string representation of an expression.\n\n    Args:\n        expression (lark.Tree): The expression to evaluate.\n        context (Context): The context in which the expression is evaluated.\n\n    Returns:\n        result (str): The string representation of the evaluated expression.\n    \"\"\"\n    result = \"\"\n    for child in expression.children:\n        str_val = str(get_value(child, context))\n        result += str_val\n    return result\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_term","title":"<code>get_term(term, context)</code>","text":"<p>Get the value of a term. This function takes a term and a context as input and returns the value of the term. Args:     term (lark.Tree): The term to evaluate.     context (Context): The context in which the term is evaluated. Returns:     Any: The value of the term.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_term(term, context):\n    \"\"\"Get the value of a term.\n    This function takes a term and a context as input and returns the value of the term.\n    Args:\n        term (lark.Tree): The term to evaluate.\n        context (Context): The context in which the term is evaluated.\n    Returns:\n        Any: The value of the term.\n    \"\"\"\n    factor = term.children[0]\n    value = get_factor(factor, context)\n    for i in range(1, len(term.children), 2):\n        operator = term.children[i].children[0]\n        factor = term.children[i + 1]\n        factor_value = get_factor(factor, context)\n        if operator.type == \"TIMES\":\n            value *= factor_value\n        elif operator.type == \"DIVIDE\":\n            value /= factor_value\n    return value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_boolean","title":"<code>get_boolean(condition)</code>","text":"<p>Get the boolean value from the parse tree. Args:     condition (lark.Tree): The parse tree node representing the boolean value. Returns:     bool: The boolean value. Raises:     Exception: If the boolean value is unknown.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_boolean(condition):\n    \"\"\"\n    Get the boolean value from the parse tree.\n    Args:\n        condition (lark.Tree): The parse tree node representing the boolean value.\n    Returns:\n        bool: The boolean value.\n    Raises:\n        Exception: If the boolean value is unknown.\n    \"\"\"\n    condition = condition.children[0]\n    if condition.type == \"TRUE\":\n        return True\n    elif condition.type == \"FALSE\":\n        return False\n    else:\n        raise Exception(\"Unknown boolean\")\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_flow_name","title":"<code>get_flow_name(tree)</code>","text":"<p>Get the flow name from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the flow name. Returns:     str: The flow name.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_flow_name(tree) -&gt; str:\n    \"\"\"\n    Get the flow name from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the flow name.\n    Returns:\n        str: The flow name.\n    \"\"\"\n    name = get_identifier(tree.children[0])\n    return name\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_identifier","title":"<code>get_identifier(tree)</code>","text":"<p>Get the identifier value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the identifier. Returns:     Any: The identifier value.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_identifier(tree):\n    \"\"\"\n    Get the identifier value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the identifier.\n    Returns:\n        Any: The identifier value.\n    \"\"\"\n    return tree.children[0].value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_literal","title":"<code>get_literal(tree)</code>","text":"<p>Get the literal value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the literal value. Returns:     Any: The literal value.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_literal(tree):\n    \"\"\"\n    Get the literal value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the literal value.\n    Returns:\n        Any: The literal value.\n    \"\"\"\n    value = tree.children[0]\n    match value.type:\n        case \"STRING_LITERAL\":\n            value = value.value[1:-1]\n        case \"NUMBER_LITERAL\":\n            value = int(value.value)\n    return value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_time","title":"<code>get_time(tree, context)</code>","text":"<p>Get the time value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the time value.     context (Context): The context object containing variable values. Returns:     int: The time value in seconds.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_time(tree, context) -&gt; int:\n    \"\"\"\n    Get the time value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the time value.\n        context (Context): The context object containing variable values.\n    Returns:\n        int: The time value in seconds.\n    \"\"\"\n    timer = tree.children[0]\n    timer = get_value(timer, context)\n    unit = tree.children[1].children[0].data\n    match unit:\n        case \"second\":\n            timer *= 1\n        case \"minute\":\n            timer *= 60\n        case \"hour\":\n            timer *= 3600\n    return timer\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_tributary_name","title":"<code>get_tributary_name(tree)</code>","text":"<p>Get the tributary name from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the tributary name. Returns:     str: The tributary name.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_tributary_name(tree) -&gt; str:\n    \"\"\"\n    Get the tributary name from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the tributary name.\n    Returns:\n        str: The tributary name.\n    \"\"\"\n    name = get_identifier(tree.children[0])\n    return name\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_value","title":"<code>get_value(tree, context)</code>","text":"<p>Get the value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the value.     context (Context): The context object containing variable values. Returns:     Any: The value.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_value(tree, context):\n    \"\"\"\n    Get the value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the value.\n        context (Context): The context object containing variable values.\n    Returns:\n        Any: The value.\n    \"\"\"\n    value = tree.children[0]\n    match value.data:\n        case \"literal\":\n            return get_literal(value)\n        case \"variable\":\n            variable_name = get_variable_name(value)\n            return context.get_variable(variable_name)\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_variable","title":"<code>get_variable(value, context)</code>","text":"<p>Get the value of a variable from the context. Args:     value (lark.Tree): The parse tree node representing the variable.     context (Context): The context object containing variable values. Returns:     Any: The value of the variable.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_variable(value, context):\n    \"\"\"\n    Get the value of a variable from the context.\n    Args:\n        value (lark.Tree): The parse tree node representing the variable.\n        context (Context): The context object containing variable values.\n    Returns:\n        Any: The value of the variable.\n    \"\"\"\n    variable_name = value.children[0].value\n    return context.get_variable(variable_name)\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_variable_name","title":"<code>get_variable_name(tree)</code>","text":"<p>Get the variable name from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the variable. Returns:     (str): The variable name.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_variable_name(tree) -&gt; str:\n    \"\"\"\n    Get the variable name from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the variable.\n    Returns:\n        (str): The variable name.\n    \"\"\"\n    return get_identifier(tree.children[0])\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.arun_handover","title":"<code>arun_handover(statement, context, speak_function, listen_function)</code>  <code>async</code>","text":"<p>Executes a handover to a specific tributary.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement object.</p> required <code>context</code> <code>Context</code> <p>The context object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking.</p> required <code>listen_function</code> <code>callable</code> <p>The function used for listening.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the specified tributary is not found.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>async def arun_handover(statement, context, speak_function, listen_function):\n    \"\"\"\n    Executes a handover to a specific tributary.\n\n    Args:\n        statement (lark.Tree): The statement object.\n        context (Context): The context object.\n        speak_function (callable): The function used for speaking.\n        listen_function (callable): The function used for listening.\n\n    Raises:\n        Exception: If the specified tributary is not found.\n    \"\"\"\n    tributary_name = get_tributary_name(statement.children[0])\n    tributary = get_tributary(tributary_name)\n    if tributary is None:\n        raise Exception(f\"Tributary {tributary_name} not found\")\n    await a_call_function(tributary, context, speak_function, listen_function)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.arun_listen","title":"<code>arun_listen(statement, context, listen_function)</code>  <code>async</code>","text":"<p>Executes the listen statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The listen statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required <code>listen_function</code> <code>callable</code> <p>The function to be called for listening.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value obtained from the listen function. None if timeout occurs.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>async def arun_listen(statement, context, listen_function):\n    \"\"\"Executes the listen statement.\n\n    Args:\n        statement (lark.Tree): The listen statement node.\n        context (Context): The execution context.\n        listen_function (callable): The function to be called for listening.\n\n    Returns:\n        (int): The value obtained from the listen function. None if timeout occurs.\n    \"\"\"\n    length = len(statement.children)\n    match length:\n        case 1:\n            value = await a_call_function(listen_function)\n            set_variable(statement.children[0], context, value)\n        case 2:\n            timer = get_time(statement.children[1], context)\n            value = await a_call_function(listen_function, timer)\n            if value is None:\n                context.set_timeout(True)\n            else:\n                set_variable(statement.children[0], context, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.arun_speak","title":"<code>arun_speak(statement, context, speak_function)</code>  <code>async</code>","text":"<p>Executes the speak function with the value obtained from the statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement from which to obtain the value.</p> required <code>context</code> <code>Context</code> <p>The context in which the statement is evaluated.</p> required <code>speak_function</code> <code>callable</code> <p>The function to be executed with the obtained value.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>async def arun_speak(statement, context, speak_function):\n    \"\"\"Executes the speak function with the value obtained from the statement.\n\n    Args:\n        statement (lark.Tree): The statement from which to obtain the value.\n        context (Context): The context in which the statement is evaluated.\n        speak_function (callable): The function to be executed with the obtained value.\n    \"\"\"\n    value = get_str_expression(statement.children[0], context)\n    await a_call_function(speak_function, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_assign","title":"<code>run_assign(statement, context)</code>","text":"<p>Assigns a value to a variable in the given context.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The assignment statement to be executed.</p> required <code>context</code> <code>Context</code> <p>The context in which the assignment is performed.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_assign(statement, context):\n    \"\"\"Assigns a value to a variable in the given context.\n\n    Args:\n        statement (lark.Tree): The assignment statement to be executed.\n        context (Context): The context in which the assignment is performed.\n    \"\"\"\n    expression = statement.children[0]\n    value = get_expression(expression, context)\n    variable = statement.children[1]\n    variable_name = get_variable_name(variable)\n    context.set_variable(variable_name, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_fetch","title":"<code>run_fetch(statement, context)</code>","text":"<p>Executes the fetch statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The fetch statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_fetch(statement, context):\n    \"\"\"Executes the fetch statement.\n\n    Args:\n        statement (lark.Tree): The fetch statement node.\n        context (Context): The execution context.\n    \"\"\"\n    value = context.get_parameter()\n    set_variable(statement.children[0], context, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_handover","title":"<code>run_handover(statement, context, speak_function, listen_function)</code>","text":"<p>Executes a handover to a specific tributary.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement object.</p> required <code>context</code> <code>Context</code> <p>The context object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking.</p> required <code>listen_function</code> <code>callable</code> <p>The function used for listening.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the specified tributary is not found.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_handover(statement, context, speak_function, listen_function):\n    \"\"\"\n    Executes a handover to a specific tributary.\n\n    Args:\n        statement (lark.Tree): The statement object.\n        context (Context): The context object.\n        speak_function (callable): The function used for speaking.\n        listen_function (callable): The function used for listening.\n\n    Raises:\n        Exception: If the specified tributary is not found.\n    \"\"\"\n    tributary_name = get_tributary_name(statement.children[0])\n    tributary = get_tributary(tributary_name)\n    if tributary is None:\n        raise Exception(f\"Tributary {tributary_name} not found\")\n    call_function(tributary, context, speak_function, listen_function)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_listen","title":"<code>run_listen(statement, context, listen_function)</code>","text":"<p>Executes the listen statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The listen statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required <code>listen_function</code> <code>callable</code> <p>The function to be called for listening.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value obtained from the listen function. None if timeout occurs.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_listen(statement, context, listen_function):\n    \"\"\"Executes the listen statement.\n\n    Args:\n        statement (lark.Tree): The listen statement node.\n        context (Context): The execution context.\n        listen_function (callable): The function to be called for listening.\n\n    Returns:\n        (int): The value obtained from the listen function. None if timeout occurs.\n    \"\"\"\n    length = len(statement.children)\n    match length:\n        case 1:\n            value = call_function(listen_function)\n            set_variable(statement.children[0], context, value)\n        case 2:\n            timer = get_time(statement.children[1], context)\n            value = call_function(listen_function, timer)\n            if value is None:\n                context.set_timeout(True)\n            else:\n                set_variable(statement.children[0], context, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_speak","title":"<code>run_speak(statement, context, speak_function)</code>","text":"<p>Executes the speak function with the value obtained from the statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement from which to obtain the value.</p> required <code>context</code> <code>Context</code> <p>The context in which the statement is evaluated.</p> required <code>speak_function</code> <code>callable</code> <p>The function to be executed with the obtained value.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_speak(statement, context, speak_function):\n    \"\"\"Executes the speak function with the value obtained from the statement.\n\n    Args:\n        statement (lark.Tree): The statement from which to obtain the value.\n        context (Context): The context in which the statement is evaluated.\n        speak_function (callable): The function to be executed with the obtained value.\n    \"\"\"\n    value = get_str_expression(statement.children[0], context)\n    call_function(speak_function, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_store","title":"<code>run_store(statement, context)</code>","text":"<p>Executes the store statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The store statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_store(statement, context):\n    \"\"\"Executes the store statement.\n\n    Args:\n        statement (lark.Tree): The store statement node.\n        context (Context): The execution context.\n    \"\"\"\n    value = get_value(statement.children[0], context)\n    context.set_parameter(value)\n</code></pre>"},{"location":"executors/#chatflow.executors.setters.set_variable","title":"<code>set_variable(tree, context, value)</code>","text":"<p>Set the value of a variable in the context.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Tree</code> <p>The tree object.</p> required <code>context</code> <code>Context</code> <p>The context object.</p> required <code>value</code> <code>any</code> <p>The value to set.</p> required Source code in <code>chatflow\\executors\\setters.py</code> <pre><code>def set_variable(tree, context, value):\n    \"\"\"Set the value of a variable in the context.\n\n    Args:\n        tree (lark.Tree): The tree object.\n        context (Context): The context object.\n        value (any): The value to set.\n\n    \"\"\"\n    variable_name = get_variable_name(tree)\n    context.set_variable(variable_name, value)\n</code></pre>"},{"location":"grammar/","title":"Grammar","text":""},{"location":"grammar/#the-grammar-of-chatflow","title":"The Grammar of ChatFlow","text":"<p>ChatFlow features an easy to learn grammar to enable intuitive authoring of conversational dialog flows. This section covers the syntax, semantics and key components of the ChatFlow language.</p>"},{"location":"grammar/#table-of-contents","title":"Table of Contents","text":"<ul> <li>The Structure of a ChatFlow Program - Overview of flows, blocks and statements</li> <li>Lexical Definitions - Tokens, identifiers, keywords, comments and literals</li> <li>Statements - Details on each statement type and its syntax</li> <li>BNF Definition - Formal context-free grammar of ChatFlow using Backus\u2013Naur form</li> </ul>"},{"location":"interpreter/","title":"Interpreter","text":""},{"location":"interpreter/#chatflow.interpreter.Interpreter","title":"<code>Interpreter</code>","text":"<p>A class that represents an interpreter for executing ChatFlow scripts.</p> <p>Parameters:</p> Name Type Description Default <code>code_path</code> <code>str</code> <p>The path to the ChatFlow script file. Defaults to None.</p> <code>None</code> <code>code</code> <code>str</code> <p>The ChatFlow script code. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>script</code> <code>str</code> <p>The ChatFlow script code.</p> <code>parser</code> <code>Lark</code> <p>The Lark parser for parsing the ChatFlow script.</p> <code>tree</code> <code>Tree</code> <p>The parsed syntax tree of the ChatFlow script.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Returns a pretty-printed representation of the parsed syntax tree.</p> Source code in <code>chatflow\\interpreter.py</code> <pre><code>class Interpreter:\n    \"\"\"\n    A class that represents an interpreter for executing ChatFlow scripts.\n\n    Args:\n        code_path (str, optional): The path to the ChatFlow script file. Defaults to None.\n        code (str, optional): The ChatFlow script code. Defaults to None.\n\n    Attributes:\n        script (str): The ChatFlow script code.\n        parser (lark.Lark): The Lark parser for parsing the ChatFlow script.\n        tree (lark.Tree): The parsed syntax tree of the ChatFlow script.\n\n    Methods:\n        __repr__(str): Returns a pretty-printed representation of the parsed syntax tree.\n\n    \"\"\"\n\n    def __init__(\n            self,\n            code_path=None,\n            code=None,\n    ):\n        if code_path:\n            with open(code_path, \"r\") as f:\n                self.script = f.read()\n        elif code:\n            self.script = code\n        self.parser = Lark(grammar, start=\"chatflow\", parser=\"lalr\")\n        self.tree = self.parser.parse(self.script)\n\n    def __repr__(self):\n        return self.tree.pretty()\n</code></pre>"},{"location":"lexical/","title":"Lexical Analysis","text":"<p>Lexical analysis is the first phase of the ChatFlow language processing. It involves breaking down the source code into tokens, which are the smallest meaningful units of the language. The lexer, also known as the tokenizer, scans the source code character by character and groups them into tokens based on predefined patterns and rules.</p>"},{"location":"lexical/#comment","title":"Comment","text":"<p>In ChatFlow, comments are denoted by a hash character (<code>#</code>) followed by the comment text. They can be used to provide explanations, document the code, or temporarily disable specific parts of the flow. Comments in ChatFlow are ignored by the language's interpreter and have no impact on the program's behavior or execution.</p> <p>For example:</p> <pre><code>flow origin {\n    # This is a comment explaining the purpose of this flow\n    speak \"Hello, world!\" # This line speaks a greeting message\n    # The following line is commented out to disable its execution\n    # listen for name\n}\n</code></pre> <p>In the above example, the comments provide additional information about the flow and the code. The interpreter ignores these comments, ensuring they don't affect the execution of the ChatFlow program.</p>"},{"location":"lexical/#identifiers-and-keywords","title":"Identifiers and Keywords","text":"<p>Identifiers are used to represent names in a programming language. In ChatFlow, an identifier is defined as a sequence of characters that follows a specific pattern.</p> <p>The pattern for identifiers in ChatFlow is defined using the following BNF notation:</p> <pre><code>IDENTIFIER ::= letter(letter | digit | \"_\")*\nletter ::= \"A\"..\"Z\" | \"a\"..\"z\"\ndigit ::= \"0\"..\"9\"  \n</code></pre> <p>An identifier must start with a letter (uppercase or lowercase) or an underscore, followed by zero or more letters, digits, or underscores. This means that identifiers can include a combination of letters (both uppercase and lowercase), digits, and underscores, but they cannot start with a digit.</p> <p>ChatFlow also has a set of reserved words or keywords that hold special meanings and cannot be used as regular identifiers. It is important to remember that these keywords must be spelled exactly as specified in the ChatFlow language and cannot be used as ordinary identifiers.</p> <p>Following are the keywords in ChatFlow:</p> <pre><code>flow        if          else        while       speak\nengage      handover    end         listen      for\nassign      to          true        false       match\nequals      larger      than        less        not\ntimeout     store       fetch\n</code></pre>"},{"location":"lexical/#literals","title":"Literals","text":"<p>In ChatFlow, literals are representations of constant values for certain built-in types.</p>"},{"location":"lexical/#string-literals","title":"String Literals","text":"<p>String literals in ChatFlow are represented by sequences of characters enclosed within double quotation marks (<code>\"</code>). They are used to denote textual data or strings.</p> <p>The BNF representation is as following:</p> <pre><code>STRING ::= '\"' (letter | digit |punctuation)* '\"'  \n</code></pre> <p>For example:</p> <pre><code>\"This is a string literal.\"\n\"Hello, world!\"\n\"12345\"\n\"Special characters: !@#$%^&amp;*()\"\n</code></pre> <p>String literals are commonly used for storing and manipulating textual data within ChatFlow scripts. They can be assigned to variables, passed as arguments to functions, concatenated, compared, and displayed as output during script execution.</p> <p>Make sure to enclose string literals within double quotation marks to indicate that they are strings.</p>"},{"location":"lexical/#number-literals","title":"Number Literals","text":"<p>Number literals in ChatFlow are used to represent numeric values, including integers and floating-point numbers.</p> <p>Here is the BNF representation of number literals in ChatFlow:</p> <pre><code>&lt;NUMBER_LITERAL&gt; ::= &lt;SIGNED_NUMBER&gt;\n\n&lt;SIGNED_NUMBER&gt; ::= [\"+\" | \"-\"] &lt;NUMBER&gt;\n\n&lt;NUMBER&gt; ::= &lt;FLOAT&gt; | &lt;INT&gt;  \n\n&lt;FLOAT&gt; ::= &lt;INT&gt; &lt;_EXP&gt; | &lt;DECIMAL&gt; &lt;_EXP&gt;?\n\n&lt;_EXP&gt; ::= (\"e\" | \"E\") &lt;SIGNED_INT&gt;\n\n&lt;SIGNED_FLOAT&gt; ::= [\"+\" | \"-\"] &lt;FLOAT&gt;  \n\n&lt;DECIMAL&gt; ::= &lt;INT&gt; \".\" &lt;INT&gt;? | \".\" &lt;INT&gt; \n\n&lt;SIGNED_INT&gt; ::= [\"+\" | \"-\"] &lt;INT&gt;\n\n&lt;INT&gt; ::= digit+\ndigit ::= \"0\"...\"9\"\n</code></pre> <p>These rules define the syntax for representing number literals in ChatFlow, allowing for the representation of both integers and floating-point numbers.</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#install-using-pypi","title":"Install using PyPI","text":"<p>You can install ChatFlow from PyPI using the following command:</p> <pre><code>pip install chatflow\n</code></pre>"},{"location":"quick-start/#install-from-source","title":"Install from source","text":"<p>Alternatively, you can install it from the source code. First, clone the repository:</p> <pre><code>git clone https://github.com/65456u/ChatFlow.git\ncd ChatFlow\n</code></pre> <p>Then, install the required packages:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Finally, install ChatFlow:</p> <pre><code>pip install .\n</code></pre>"},{"location":"quick-start/#initializing-the-interpreter","title":"Initializing the Interpreter","text":"<p>To run a ChatFlow program, you need to create an <code>Interpreter</code> object using the ChatFlow code you have written.</p> <p>You can directly create an <code>Interpreter</code> object and pass the code as a string, like this:</p> <pre><code>from chatflow import Interpreter\n\ncode = \"\"\"\nflow origin {\n  speak \"Hello, world!\" \n}\n\"\"\"\n\ninterpreter = Interpreter(code=code)\n</code></pre> <p>Alternatively, you can create an <code>Interpreter</code> object by specifying the path to a file containing your ChatFlow code:</p> <pre><code>interpreter = Interpreter(code_path=\"hello.flow\")\n</code></pre>"},{"location":"quick-start/#creating-a-runtime-instance","title":"Creating a Runtime Instance","text":"<p>The <code>Runtime</code> class is responsible for executing the ChatFlow program.</p> <p>You can create a <code>Runtime</code> instance by passing the <code>Interpreter</code> object along with your custom <code>speak</code> and <code>listen</code> functions. If you don't provide custom functions, the runtime will use the built-in default <code>speak</code> and <code>listen</code> methods.</p> <pre><code>from chatflow import Interpreter, Runtime\n\n\ndef my_speak_function(message):\n# Custom speak function implementation\n# ...\n\ndef my_listen_function(timer):\n# Custom listen function implementation\n# ...\n\n\nruntime = Runtime(interpreter, my_speak_function, my_listen_function)\n</code></pre> <p>By providing your own <code>speak</code> and <code>listen</code> functions, you can customize the behavior of the ChatFlow program according to your needs.</p>"},{"location":"quick-start/#running-the-program","title":"Running the Program","text":"<p>To execute the ChatFlow program, simply call the <code>run()</code> method on the <code>Runtime</code> instance:</p> <pre><code>runtime.run()\n</code></pre> <p>This will start the execution of the ChatFlow program, which will proceed according to the defined flows and interactions specified in the code.</p>"},{"location":"references/","title":"API References","text":"<p>API reference documentation covers the key classes and components of the ChatFlow runtime environment.</p>"},{"location":"references/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Interpreter - Parses ChatFlow code and builds an abstract syntax tree</li> <li>Runtime - Interprets and executes the ChatFlow program </li> <li>Context - Maintains state and data during execution</li> <li>Executors - Functions that execute individual ChatFlow statements</li> <li>Utils - Utility functions</li> </ul>"},{"location":"runtime/","title":"Runtime","text":""},{"location":"runtime/#chatflow.runtime.Runtime","title":"<code>Runtime</code>","text":"<p>The Runtime class represents the execution environment for the ChatFlow program.</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>Tree</code> <p>The abstract syntax tree of the ChatFlow program.</p> <code>flow_dict</code> <code>dict</code> <p>A dictionary mapping flow names to their corresponding blocks.</p> <code>exit</code> <code>bool</code> <p>A flag indicating whether the chat flow should exit.</p> <code>contextStack</code> <code>list</code> <p>A stack of context objects representing the execution context.</p> <code>speak_function</code> <code>callable</code> <p>The function used for speaking.</p> <code>listen_function</code> <code>callable</code> <p>The function used for listening.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the Runtime object.</p> <code>register_flow</code> <p>Registers the flows defined in the ChatFlow program.</p> <code>run</code> <p>Runs the chat flow.</p> <code>arun</code> <p>Runs the chat flow asynchronously.</p> <code>arun_flow</code> <p>Runs a specific flow in the ChatFlow program asynchronously.</p> <code>run_flow</code> <p>Runs a specific flow in the ChatFlow program.</p> <code>arun_block</code> <p>Runs a block of statements in the ChatFlow program asynchronously.</p> <code>run_block</code> <p>Runs a block of statements in the ChatFlow program.</p> <code>run_statement</code> <p>Runs a single statement in the ChatFlow program.</p> <code>arun_statement</code> <p>Runs a single statement in the ChatFlow program asynchronously.</p> <code>arun_if</code> <p>Runs an if statement in the ChatFlow program asynchronously.</p> <code>run_if</code> <p>Runs an if statement in the ChatFlow program.</p> <code>arun_else</code> <p>Runs an else statement in the ChatFlow program asynchronously.</p> <code>run_else</code> <p>Runs an else statement in the ChatFlow program.</p> <code>arun_engage</code> <p>Runs an engage statement in the ChatFlow program asynchronously.</p> <code>run_engage</code> <p>Runs an engage statement in the ChatFlow program.</p> <code>arun_while</code> <p>Runs a while statement in the ChatFlow program asynchronously.</p> <code>run_while</code> <p>Runs a while statement in the ChatFlow program.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>class Runtime:\n    \"\"\"\n    The Runtime class represents the execution environment for the ChatFlow program.\n\n    Attributes:\n        tree (lark.Tree): The abstract syntax tree of the ChatFlow program.\n        flow_dict (dict): A dictionary mapping flow names to their corresponding blocks.\n        exit (bool): A flag indicating whether the chat flow should exit.\n        contextStack (list): A stack of context objects representing the execution context.\n        speak_function (callable): The function used for speaking.\n        listen_function (callable): The function used for listening.\n\n    Methods:\n        __init__(self, interpreter, speak_function=None, listen_function=None): Initializes the Runtime object.\n        register_flow(self): Registers the flows defined in the ChatFlow program.\n        run(self): Runs the chat flow.\n        arun(self): Runs the chat flow asynchronously.\n        arun_flow(self, flow_name, parameter=None): Runs a specific flow in the ChatFlow program asynchronously.\n        run_flow(self, flow_name, parameter=None): Runs a specific flow in the ChatFlow program.\n        arun_block(self, block, context): Runs a block of statements in the ChatFlow program asynchronously.\n        run_block(self, block, context): Runs a block of statements in the ChatFlow program.\n        run_statement(self, statement, context): Runs a single statement in the ChatFlow program.\n        arun_statement(self, statement, context): Runs a single statement in the ChatFlow program asynchronously.\n        arun_if(self, statement, context): Runs an if statement in the ChatFlow program asynchronously.\n        run_if(self, statement, context): Runs an if statement in the ChatFlow program.\n        arun_else(self, statement, context): Runs an else statement in the ChatFlow program asynchronously.\n        run_else(self, statement, context): Runs an else statement in the ChatFlow program.\n        arun_engage(self, statement, context): Runs an engage statement in the ChatFlow program asynchronously.\n        run_engage(self, statement, context): Runs an engage statement in the ChatFlow program.\n        arun_while(self, statement, context): Runs a while statement in the ChatFlow program asynchronously.\n        run_while(self, statement, context): Runs a while statement in the ChatFlow program.\n    \"\"\"\n\n    def __init__(\n            self, interpreter, speak_function=None, listen_function=None\n    ):\n        \"\"\"Initialize the Runtime object.\n\n        Args:\n            interpreter (Interpreter): The interpreter object.\n            speak_function (callable, optional): The function used for speaking. Defaults to print.\n            listen_function (callable, optional): The function used for listening. Defaults to read_input_with_timeout.\n\n        \"\"\"\n        self.tree = interpreter.tree\n        self.flow_dict = {}\n        self.exit = False\n        self.register_flow()\n        self.contextStack = []\n        self.speak_function = speak_function\n        self.listen_function = listen_function\n\n    def register_flow(self):\n        \"\"\"\n        Register the flows defined in the ChatFlow program.\n        \"\"\"\n        for flow in self.tree.children:\n            flow_name = flow.children[0].children[0].children[0]\n            block = flow.children[1]\n            self.flow_dict[flow_name] = block\n\n    def run(self):\n        \"\"\"\n        Runs the chat flow.\n\n        If the speak_function is not provided, it defaults to the print function.\n        If the listen_function is not provided, it defaults to the read_input_with_timeout function.\n\n        The chat flow starts from the \"origin\" flow.\n        \"\"\"\n        if self.speak_function is None:\n            self.speak_function = print\n        if self.listen_function is None:\n            self.listen_function = read_input_with_timeout\n        self.run_flow(\"origin\")\n\n    async def arun(self):\n        \"\"\"Runs the chatflow asynchronously.\n\n        This method is responsible for executing the chatflow asynchronously.\n        It sets the default speak and listen functions if not provided,\n        and then calls the `arun_flow` method to start the chatflow.\n\n        \"\"\"\n        if self.speak_function is None:\n            self.speak_function = aprint\n        if self.listen_function is None:\n            self.listen_function = a_read_input_with_timeout\n        await self.arun_flow(\"origin\")\n\n    async def arun_flow(self, flow_name, parameter=None):\n        \"\"\"\n        Run a specific flow in the ChatFlow program.\n\n        Args:\n            flow_name (str): The name of the flow to run.\n            parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n        \"\"\"\n        if flow_name not in self.flow_dict:\n            raise Exception(f\"Flow {flow_name} not found\")\n        tree = self.flow_dict[flow_name]\n        context = Context(parameter, tree)\n        self.contextStack.append(context)\n        await self.arun_block(tree, context)\n        self.contextStack.pop()\n\n    def run_flow(self, flow_name, parameter=None):\n        \"\"\"\n        Run a specific flow in the ChatFlow program.\n\n        Args:\n            flow_name (str): The name of the flow to run.\n            parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n        \"\"\"\n        if flow_name not in self.flow_dict:\n            raise Exception(f\"Flow {flow_name} not found\")\n        tree = self.flow_dict[flow_name]\n        context = Context(parameter, tree)\n        self.contextStack.append(context)\n        self.run_block(tree, context)\n        self.contextStack.pop()\n\n    async def arun_block(self, block, context):\n        \"\"\"\n        Run a block of statements in the ChatFlow program.\n\n        Args:\n            block (lark.Tree): The block of statements to run.\n            context (Context): The current context.\n        \"\"\"\n        context.push_scope()\n        for statement in block.children:\n            if self.exit:\n                return\n            await self.arun_statement(statement, context)\n\n    def run_block(self, block, context):\n        \"\"\"\n        Run a block of statements in the ChatFlow program.\n\n        Args:\n            block (lark.Tree): The block of statements to run.\n            context (Context): The current context.\n        \"\"\"\n        context.push_scope()\n        for statement in block.children:\n            if self.exit:\n                context.pop_scope()\n                return\n            self.run_statement(statement, context)\n        context.pop_scope()\n\n    def run_statement(self, statement, context):\n        \"\"\"\n        Run a single statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The statement to run.\n            context (Context): The current context.\n        \"\"\"\n        statement = statement.children[0]\n        state_type = statement.data\n        match state_type:\n            case \"speak_statement\":\n                run_speak(statement, context, self.speak_function)\n            case \"listen_statement\":\n                run_listen(statement, context, self.listen_function)\n            case \"if_statement\":\n                self.run_if(statement, context)\n            case \"engage_statement\":\n                self.run_engage(statement, context)\n            case \"assign_statement\":\n                run_assign(statement, context)\n            case \"end_statement\":\n                self.exit = True\n            case \"handover_statement\":\n                run_handover(\n                    statement, context, self.speak_function, self.listen_function\n                )\n            case \"while_statement\":\n                self.run_while(statement, context)\n            case \"store_statement\":\n                run_store(statement, context)\n            case \"fetch_statement\":\n                run_fetch(statement, context)\n            case \"block\":\n                self.run_block(statement, context)\n\n    async def arun_statement(self, statement, context):\n        \"\"\"\n        Run a single statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The statement to run.\n            context (Context): The current context.\n        \"\"\"\n        statement = statement.children[0]\n        state_type = statement.data\n        match state_type:\n            case \"speak_statement\":\n                await arun_speak(statement, context, self.speak_function)\n            case \"listen_statement\":\n                await arun_listen(statement, context, self.listen_function)\n            case \"if_statement\":\n                await self.arun_if(statement, context)\n            case \"engage_statement\":\n                await self.arun_engage(statement, context)\n            case \"assign_statement\":\n                run_assign(statement, context)\n            case \"end_statement\":\n                self.exit = True\n            case \"handover_statement\":\n                await arun_handover(\n                    statement, context, self.speak_function, self.listen_function\n                )\n            case \"while_statement\":\n                await self.arun_while(statement, context)\n            case \"store_statement\":\n                run_store(statement, context)\n            case \"block\":\n                await self.arun_block(statement, context)\n\n    async def arun_if(self, statement, context):\n        \"\"\"\n        Run an if statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The if statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        result = get_condition(condition, context)\n        if result:\n            await self.arun_block(statement.children[1], context)\n        else:\n            if len(statement.children) == 3:\n                await self.arun_else(statement.children[2], context)\n\n    def run_if(self, statement, context):\n        \"\"\"\n        Run an if statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The if statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        result = get_condition(condition, context)\n        if result:\n            self.run_block(statement.children[1], context)\n        else:\n            if len(statement.children) == 3:\n                self.run_else(statement.children[2], context)\n\n    async def arun_else(self, statement, context):\n        \"\"\"\n        Run an else statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The else statement to run.\n            context (Context): The current context.\n        \"\"\"\n        else_statement = statement.children[0]\n        match else_statement.data:\n            case \"block\":\n                await self.arun_block(else_statement, context)\n            case \"if_statement\":\n                await self.arun_if(else_statement, context)\n\n    def run_else(self, statement, context):\n        \"\"\"\n        Run an else statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The else statement to run.\n            context (Context): The current context.\n        \"\"\"\n        else_statement = statement.children[0]\n        match else_statement.data:\n            case \"block\":\n                self.run_block(else_statement, context)\n            case \"if_statement\":\n                self.run_if(else_statement, context)\n\n    async def arun_engage(self, statement, context):\n        \"\"\"\n        Run an engage statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The engage statement to run.\n            context (Context): The current context.\n        \"\"\"\n        flow_name = get_flow_name(statement.children[0])\n        await self.arun_flow(flow_name, context.get_parameter())\n\n    def run_engage(self, statement, context):\n        \"\"\"\n        Run an engage statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The engage statement to run.\n            context (Context): The current context.\n        \"\"\"\n        flow_name = get_flow_name(statement.children[0])\n        self.run_flow(flow_name, context.get_parameter())\n\n    async def arun_while(self, statement, context):\n        \"\"\"\n        Run a while statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The while statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        while get_condition(condition, context):\n            await self.arun_block(statement.children[1], context)\n\n    def run_while(self, statement, context):\n        \"\"\"\n        Run a while statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The while statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        while get_condition(condition, context):\n            if self.exit:\n                return\n            self.run_block(statement.children[1], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.__init__","title":"<code>__init__(interpreter, speak_function=None, listen_function=None)</code>","text":"<p>Initialize the Runtime object.</p> <p>Parameters:</p> Name Type Description Default <code>interpreter</code> <code>Interpreter</code> <p>The interpreter object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking. Defaults to print.</p> <code>None</code> <code>listen_function</code> <code>callable</code> <p>The function used for listening. Defaults to read_input_with_timeout.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>def __init__(\n        self, interpreter, speak_function=None, listen_function=None\n):\n    \"\"\"Initialize the Runtime object.\n\n    Args:\n        interpreter (Interpreter): The interpreter object.\n        speak_function (callable, optional): The function used for speaking. Defaults to print.\n        listen_function (callable, optional): The function used for listening. Defaults to read_input_with_timeout.\n\n    \"\"\"\n    self.tree = interpreter.tree\n    self.flow_dict = {}\n    self.exit = False\n    self.register_flow()\n    self.contextStack = []\n    self.speak_function = speak_function\n    self.listen_function = listen_function\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun","title":"<code>arun()</code>  <code>async</code>","text":"<p>Runs the chatflow asynchronously.</p> <p>This method is responsible for executing the chatflow asynchronously. It sets the default speak and listen functions if not provided, and then calls the <code>arun_flow</code> method to start the chatflow.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun(self):\n    \"\"\"Runs the chatflow asynchronously.\n\n    This method is responsible for executing the chatflow asynchronously.\n    It sets the default speak and listen functions if not provided,\n    and then calls the `arun_flow` method to start the chatflow.\n\n    \"\"\"\n    if self.speak_function is None:\n        self.speak_function = aprint\n    if self.listen_function is None:\n        self.listen_function = a_read_input_with_timeout\n    await self.arun_flow(\"origin\")\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_block","title":"<code>arun_block(block, context)</code>  <code>async</code>","text":"<p>Run a block of statements in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Tree</code> <p>The block of statements to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_block(self, block, context):\n    \"\"\"\n    Run a block of statements in the ChatFlow program.\n\n    Args:\n        block (lark.Tree): The block of statements to run.\n        context (Context): The current context.\n    \"\"\"\n    context.push_scope()\n    for statement in block.children:\n        if self.exit:\n            return\n        await self.arun_statement(statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_else","title":"<code>arun_else(statement, context)</code>  <code>async</code>","text":"<p>Run an else statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The else statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_else(self, statement, context):\n    \"\"\"\n    Run an else statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The else statement to run.\n        context (Context): The current context.\n    \"\"\"\n    else_statement = statement.children[0]\n    match else_statement.data:\n        case \"block\":\n            await self.arun_block(else_statement, context)\n        case \"if_statement\":\n            await self.arun_if(else_statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_engage","title":"<code>arun_engage(statement, context)</code>  <code>async</code>","text":"<p>Run an engage statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The engage statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_engage(self, statement, context):\n    \"\"\"\n    Run an engage statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The engage statement to run.\n        context (Context): The current context.\n    \"\"\"\n    flow_name = get_flow_name(statement.children[0])\n    await self.arun_flow(flow_name, context.get_parameter())\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_flow","title":"<code>arun_flow(flow_name, parameter=None)</code>  <code>async</code>","text":"<p>Run a specific flow in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>flow_name</code> <code>str</code> <p>The name of the flow to run.</p> required <code>parameter</code> <code>any</code> <p>The parameter to pass to the flow. Defaults to None.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_flow(self, flow_name, parameter=None):\n    \"\"\"\n    Run a specific flow in the ChatFlow program.\n\n    Args:\n        flow_name (str): The name of the flow to run.\n        parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n    \"\"\"\n    if flow_name not in self.flow_dict:\n        raise Exception(f\"Flow {flow_name} not found\")\n    tree = self.flow_dict[flow_name]\n    context = Context(parameter, tree)\n    self.contextStack.append(context)\n    await self.arun_block(tree, context)\n    self.contextStack.pop()\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_if","title":"<code>arun_if(statement, context)</code>  <code>async</code>","text":"<p>Run an if statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The if statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_if(self, statement, context):\n    \"\"\"\n    Run an if statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The if statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    result = get_condition(condition, context)\n    if result:\n        await self.arun_block(statement.children[1], context)\n    else:\n        if len(statement.children) == 3:\n            await self.arun_else(statement.children[2], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_statement","title":"<code>arun_statement(statement, context)</code>  <code>async</code>","text":"<p>Run a single statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_statement(self, statement, context):\n    \"\"\"\n    Run a single statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The statement to run.\n        context (Context): The current context.\n    \"\"\"\n    statement = statement.children[0]\n    state_type = statement.data\n    match state_type:\n        case \"speak_statement\":\n            await arun_speak(statement, context, self.speak_function)\n        case \"listen_statement\":\n            await arun_listen(statement, context, self.listen_function)\n        case \"if_statement\":\n            await self.arun_if(statement, context)\n        case \"engage_statement\":\n            await self.arun_engage(statement, context)\n        case \"assign_statement\":\n            run_assign(statement, context)\n        case \"end_statement\":\n            self.exit = True\n        case \"handover_statement\":\n            await arun_handover(\n                statement, context, self.speak_function, self.listen_function\n            )\n        case \"while_statement\":\n            await self.arun_while(statement, context)\n        case \"store_statement\":\n            run_store(statement, context)\n        case \"block\":\n            await self.arun_block(statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_while","title":"<code>arun_while(statement, context)</code>  <code>async</code>","text":"<p>Run a while statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The while statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_while(self, statement, context):\n    \"\"\"\n    Run a while statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The while statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    while get_condition(condition, context):\n        await self.arun_block(statement.children[1], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.register_flow","title":"<code>register_flow()</code>","text":"<p>Register the flows defined in the ChatFlow program.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>def register_flow(self):\n    \"\"\"\n    Register the flows defined in the ChatFlow program.\n    \"\"\"\n    for flow in self.tree.children:\n        flow_name = flow.children[0].children[0].children[0]\n        block = flow.children[1]\n        self.flow_dict[flow_name] = block\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run","title":"<code>run()</code>","text":"<p>Runs the chat flow.</p> <p>If the speak_function is not provided, it defaults to the print function. If the listen_function is not provided, it defaults to the read_input_with_timeout function.</p> <p>The chat flow starts from the \"origin\" flow.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>def run(self):\n    \"\"\"\n    Runs the chat flow.\n\n    If the speak_function is not provided, it defaults to the print function.\n    If the listen_function is not provided, it defaults to the read_input_with_timeout function.\n\n    The chat flow starts from the \"origin\" flow.\n    \"\"\"\n    if self.speak_function is None:\n        self.speak_function = print\n    if self.listen_function is None:\n        self.listen_function = read_input_with_timeout\n    self.run_flow(\"origin\")\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_block","title":"<code>run_block(block, context)</code>","text":"<p>Run a block of statements in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Tree</code> <p>The block of statements to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_block(self, block, context):\n    \"\"\"\n    Run a block of statements in the ChatFlow program.\n\n    Args:\n        block (lark.Tree): The block of statements to run.\n        context (Context): The current context.\n    \"\"\"\n    context.push_scope()\n    for statement in block.children:\n        if self.exit:\n            context.pop_scope()\n            return\n        self.run_statement(statement, context)\n    context.pop_scope()\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_else","title":"<code>run_else(statement, context)</code>","text":"<p>Run an else statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The else statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_else(self, statement, context):\n    \"\"\"\n    Run an else statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The else statement to run.\n        context (Context): The current context.\n    \"\"\"\n    else_statement = statement.children[0]\n    match else_statement.data:\n        case \"block\":\n            self.run_block(else_statement, context)\n        case \"if_statement\":\n            self.run_if(else_statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_engage","title":"<code>run_engage(statement, context)</code>","text":"<p>Run an engage statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The engage statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_engage(self, statement, context):\n    \"\"\"\n    Run an engage statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The engage statement to run.\n        context (Context): The current context.\n    \"\"\"\n    flow_name = get_flow_name(statement.children[0])\n    self.run_flow(flow_name, context.get_parameter())\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_flow","title":"<code>run_flow(flow_name, parameter=None)</code>","text":"<p>Run a specific flow in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>flow_name</code> <code>str</code> <p>The name of the flow to run.</p> required <code>parameter</code> <code>any</code> <p>The parameter to pass to the flow. Defaults to None.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_flow(self, flow_name, parameter=None):\n    \"\"\"\n    Run a specific flow in the ChatFlow program.\n\n    Args:\n        flow_name (str): The name of the flow to run.\n        parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n    \"\"\"\n    if flow_name not in self.flow_dict:\n        raise Exception(f\"Flow {flow_name} not found\")\n    tree = self.flow_dict[flow_name]\n    context = Context(parameter, tree)\n    self.contextStack.append(context)\n    self.run_block(tree, context)\n    self.contextStack.pop()\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_if","title":"<code>run_if(statement, context)</code>","text":"<p>Run an if statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The if statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_if(self, statement, context):\n    \"\"\"\n    Run an if statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The if statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    result = get_condition(condition, context)\n    if result:\n        self.run_block(statement.children[1], context)\n    else:\n        if len(statement.children) == 3:\n            self.run_else(statement.children[2], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_statement","title":"<code>run_statement(statement, context)</code>","text":"<p>Run a single statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_statement(self, statement, context):\n    \"\"\"\n    Run a single statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The statement to run.\n        context (Context): The current context.\n    \"\"\"\n    statement = statement.children[0]\n    state_type = statement.data\n    match state_type:\n        case \"speak_statement\":\n            run_speak(statement, context, self.speak_function)\n        case \"listen_statement\":\n            run_listen(statement, context, self.listen_function)\n        case \"if_statement\":\n            self.run_if(statement, context)\n        case \"engage_statement\":\n            self.run_engage(statement, context)\n        case \"assign_statement\":\n            run_assign(statement, context)\n        case \"end_statement\":\n            self.exit = True\n        case \"handover_statement\":\n            run_handover(\n                statement, context, self.speak_function, self.listen_function\n            )\n        case \"while_statement\":\n            self.run_while(statement, context)\n        case \"store_statement\":\n            run_store(statement, context)\n        case \"fetch_statement\":\n            run_fetch(statement, context)\n        case \"block\":\n            self.run_block(statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_while","title":"<code>run_while(statement, context)</code>","text":"<p>Run a while statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The while statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_while(self, statement, context):\n    \"\"\"\n    Run a while statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The while statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    while get_condition(condition, context):\n        if self.exit:\n            return\n        self.run_block(statement.children[1], context)\n</code></pre>"},{"location":"statement/","title":"Statements","text":""},{"location":"statement/#statements","title":"Statements","text":"<p>The ChatFlow statement consists of various types of statements that control the conversation flow and interact with the user.</p>"},{"location":"statement/#if-statement","title":"If Statement","text":"<p>The if statement in ChatFlow allows you to introduce conditional branching within your conversation flow. It enables you to make decisions based on specific conditions and execute different sets of statements accordingly.</p> <p>The syntax for the if statement in ChatFlow is as follows:</p> <pre><code>&lt;if_statement&gt; ::= \"if\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\" &lt;else_statement&gt;?\n\n&lt;else_statement&gt; ::= \"else\" \"{\" &lt;block&gt; \"}\"\n                  | \"else\" &lt;if_statement&gt;\n</code></pre> <p>In this syntax, the \"condition\" represents an expression that evaluates to a Boolean value. If the condition is true, the statements within the first block are executed. Optionally, an \"else\" block can be included, which contains statements that are executed when the condition is false. The \"else\" block can either be a block of statements or another if statement, allowing for nested conditional logic.</p>"},{"location":"statement/#speak-statement","title":"Speak Statement","text":"<p>The speak statement is used to send a message or response to the user during the conversation. It allows you to provide information, ask questions, or guide the user through the interaction.</p> <p>The syntax for the speak statement in ChatFlow is as follows:</p> <pre><code>&lt;speak_statement&gt; ::= \"speak\" &lt;str_expression&gt;  \n\n&lt;str_expression&gt; ::= &lt;value&gt; (\"+\" &lt;value&gt;)*\n</code></pre> <p>In this syntax, the \"str_expression\" represents the content of the message to be spoken. It can be a concatenation of multiple values using the \"+\" operator. The values can be string literals, variable names, or expressions that evaluate to a string.</p>"},{"location":"statement/#engage-statement","title":"Engage Statement","text":"<p>The engage statement in ChatFlow allows you to transition from the current flow to another flow. It enables you to modularize your conversation and organize it into separate flows.</p> <p>The syntax for the engage statement in ChatFlow is as follows:</p> <pre><code>&lt;engage_statement&gt; ::= \"engage\" &lt;flow_name&gt;\n</code></pre> <p>In this syntax, the \"flow_name\" represents the name of the flow that you want to engage with. It allows you to initiate another flow within the current flow, continuing the conversation in a different context.</p>"},{"location":"statement/#handover-statement","title":"Handover Statement","text":"<p>The handover statement in ChatFlow is used to transfer the conversation to another tributary, which is an user-defined external program. It allows you to hand over the conversation to a different system or service for further processing.</p> <pre><code>&lt;handover_statement&gt; ::= \"handover\" &lt;tributary_name&gt;\n</code></pre>"},{"location":"statement/#end-statement","title":"End Statement","text":"<p>The end statement in ChatFlow is used to stop the execution of the entire program. It terminates the conversation and exits the ChatFlow program.</p> <pre><code>end_statement    ::= \"end\"\n</code></pre>"},{"location":"statement/#listen-statement","title":"Listen Statement","text":"<p>The listen statement in ChatFlow is used to listen for user input during the conversation. It allows the ChatFlow program to wait for the user to provide a response before continuing with the execution. If timeout is reached, the timeout variable in the context if automatically set.</p> <pre><code>&lt;listen_statement&gt; ::= \"listen\" \"for\" &lt;variable&gt; (\"for\" &lt;time&gt;)?\n</code></pre>"},{"location":"statement/#assign-statement","title":"Assign Statement","text":"<p>The assign statement in ChatFlow is used to assign a value to a variable. It allows you to store and manipulate data within the ChatFlow program.</p> <pre><code>&lt;assign_statement&gt; ::= \"assign\" &lt;expression&gt; \"to\" &lt;variable&gt;\n</code></pre>"},{"location":"statement/#while-statement","title":"While Statement","text":"<p>The while statement in ChatFlow allows you to create a loop that executes a block of statements repeatedly as long as a specific condition is true.</p> <pre><code>&lt;while_statement&gt; ::= \"while\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\"\n</code></pre>"},{"location":"statement/#store-statement","title":"Store Statement","text":"<p>The store statement in ChatFlow is used to store a value in the parameter within the context, enabling the passing of information from one flow to another flow or a tributary. It allows you to store data that can be accessed and utilized across different parts of the conversation.</p> <pre><code>&lt;store_statement&gt; ::= \"store\" &lt;value&gt;\n</code></pre> <p>In this syntax, the \"value\" represents the data or value that you want to store in the parameter within the context. By utilizing the store statement, you can preserve and retrieve information as needed throughout the conversation. This feature facilitates seamless information sharing and enhances the flexibility and functionality of your ChatFlow program.</p>"},{"location":"statement/#fetch-statement","title":"Fetch Statement","text":"<p>The fetch statement in ChatFlow is used to retrieve the stored value from the parameter within the context. It allows you to access data that has been previously stored using the store statement.</p> <pre><code>&lt;fetch_statement&gt; ::= \"fetch\" &lt;variable&gt;\n</code></pre> <p>In this syntax, the \"value\" represents the data or value that you want to retrieve from the parameter within the context. By utilizing the fetch statement, you can access stored information and use it in your conversation flow. This enables you to leverage previously stored data and incorporate it into your ChatFlow program in a dynamic and customized manner.</p>"},{"location":"structure/","title":"Structure of ChatFlow Program","text":"<p>The structure of a ChatFlow program is based on three key concepts: flow, block, statement, and tributary.</p>"},{"location":"structure/#flow","title":"Flow","text":"<p>A flow in ChatFlow represents a sequence of steps or actions that define the conversational logic. It defines the structure and flow of the conversation between the user and the ChatFlow program. A flow is defined using the keyword \"flow\" followed by a flow name and enclosed within curly braces.</p> <p>The BNF (Backus-Naur Form) representation of a flow in ChatFlow is as follows:</p> <pre><code>&lt;flow&gt; ::= \"flow\" &lt;flow_name&gt; \"{\" &lt;block&gt; \"}\"\n&lt;flow_name&gt; ::= &lt;identifier&gt;\n</code></pre> <p>In this syntax, the \"flow_name\" is a user-defined identifier that uniquely identifies the flow within the program. It should be chosen to reflect the purpose or content of the flow. The \"block\" represents a collection of statements that define the actions and interactions within the flow. These statements can include if statements, speak statements, engage statements, handover statements, and more.</p> <p>To transition from one flow to another, you can use the engage statement. The engage statement allows you to initiate another flow within the current flow, enabling you to create complex conversation flows and modularize your ChatFlow program. </p> <p>To engage a specific flow, you use the following syntax:</p> <pre><code>engage flow_name\n</code></pre> <p>Here, \"flow_name\" refers to the name of the flow you want to transition to. By using the engage statement, you can seamlessly navigate between different flows and create dynamic and interactive conversations for your users.</p>"},{"location":"structure/#block","title":"Block","text":"<p>A block in ChatFlow is a series of statements grouped together within a flow. It represents a section of code that is executed sequentially. A block is enclosed within curly braces and can contain multiple statements.</p> <p>The definition of a block in ChatFlow can be represented as:</p> <pre><code>&lt;flow&gt; ::= \"flow\" &lt;flow_name&gt; \"{\" &lt;block&gt; \"}\"\n</code></pre> <p>In this representation, \"statement*\" denotes zero or more statements within the block. Each statement represents a specific action or instruction within the flow.</p> <p>When you create a block, any variables declared within that block are only accessible within that block's scope. They are not visible outside of the block or in other blocks within the flow.</p> <p>Here's an example that demonstrates the usage of a block in ChatFlow:</p> <pre><code>flow origin {\n    # Variables declared within the origin flow block\n    assign \"John\" to name\n    assign 25 to age\n\n    # Start of a block\n    {\n        # Variable declared within the block\n        assign \"Smith\" to lastName\n\n        speak \"Full name: \" + name + \" \" + lastName\n        speak \"Age: \" + age\n    }  # End of the block\n\n    # The following line will cause an error because lastName is not accessible here\n    speak \"Last name: \" + lastName\n}\n</code></pre> <p>In the above example, the block is defined within the <code>origin</code> flow. Inside the block, a variable <code>lastName</code> is declared, and the code within the block can access the <code>name</code>, <code>age</code>, and <code>lastName</code> variables. However, outside the block, the <code>lastName</code> variable is not accessible, and attempting to access it will result in an error.</p> <p>By using blocks, you can control the scope of variables and organize your code into logical sections. This allows for better code readability and prevents variable name conflicts between different parts of your ChatFlow program.</p>"},{"location":"structure/#statement","title":"Statement","text":"<p>A statement in ChatFlow is a basic unit of code that represents an action or instruction within a flow. It performs a specific task or interaction with the user. ChatFlow supports various types of statements, including conditionals, speaking to the user, engaging with other flows, listening for user input, assigning values to variables, looping constructs, and more.</p> <p>The BNF representation of a statement in ChatFlow can be defined as:</p> <pre><code>&lt;statement&gt; ::= &lt;if_statement&gt;\n              | &lt;speak_statement&gt;  \n              | &lt;engage_statement&gt;\n              | &lt;handover_statement&gt;\n              | &lt;end_statement&gt;\n              | &lt;listen_statement&gt;\n              | &lt;assign_statement&gt;\n              | &lt;while_statement&gt;  \n              | &lt;store_statement&gt;\n              | &lt;fetch_statement&gt;\n              | \"{\" &lt;block&gt; \"}\"\n</code></pre> <p>Each statement type has its own syntax and purpose within the ChatFlow program.</p> <p>For more detailed information on statements, please refer to statement.</p>"},{"location":"structure/#tributary","title":"Tributary","text":"<p>Tributaries are external functions that can be seamlessly integrated into your ChatFlow program to perform custom operations or interact with external services. They allow you to extend the functionality of ChatFlow by incorporating specific logic or functionality that is not provided by the built-in statements.</p> <p>To define a tributary in ChatFlow, you can use the <code>@register_tributary</code> decorator followed by the tributary name and the function definition. The function should accept the <code>context</code>, <code>speak_function</code>, and <code>listen_function</code> as parameters. The <code>context</code> parameter provides access to the ChatFlow context, allowing you to retrieve or modify parameters and other contextual information. The <code>speak_function</code> is used to send messages or responses to the user, while the <code>listen_function</code> is used to listen for user input.</p> <p>Here's an example of defining a tributary named \"print_parameter\" using Python:</p> <pre><code>@register_tributary(\"print_parameter\")\ndef display(context, speak_function, listen_function):\n    print(context.get_parameter())\n</code></pre> <p>In this example, the <code>display</code> function is registered as the \"print_parameter\" tributary. Within the function, you have access to the ChatFlow context through the <code>context</code> parameter. You can use the <code>speak_function</code> to send messages or responses to the user, and the <code>listen_function</code> to listen for user input. In this case, the function simply prints the value of a parameter using the <code>get_parameter()</code> method of the context.</p> <p>To use a tributary within your ChatFlow program, you can use the <code>handover</code> statement followed by the name of the tributary. This allows you to transfer the conversation to the specified tributary for further processing.</p> <p>Here's an example of using the <code>handover</code> statement to invoke the \"display\" tributary:</p> <pre><code>handover print_parameter\n</code></pre> <p>In this example, the <code>print_parameter</code> statement transfers the conversation to the \"display\" tributary, allowing it to perform its specific logic or functionality. Once the tributary has completed its task, the control can be handed back to the ChatFlow program.</p> <p>By leveraging tributaries, you can integrate external functions or services seamlessly into your ChatFlow program, enhancing its capabilities and enabling custom operations based on your specific requirements.</p>"},{"location":"tutorials/","title":"Learning ChatFlow","text":""},{"location":"tutorials/#the-first-chatflow-program","title":"The First ChatFlow Program","text":"<p>Let's write our first ChatFlow program that says \"hello\" to the world.</p> <pre><code>flow origin {\n  speak \"Hello, world!\" \n}\n</code></pre> <p>To run this program, you can use the following Python code:</p> <pre><code>from chatflow import Interpreter, Runtime\n\ncode = \"\"\"\nflow origin {\n  speak \"Hello, world!\" \n}\n\"\"\"\n\ninterpreter = Interpreter(code=code)\nruntime = Runtime(interpreter)\nruntime.run() \n</code></pre> <p>The current program only has one flow called \"origin,\" which serves as the entry point of the entire ChatFlow program.</p> <p>We first create an <code>Interpreter</code> object using the provided code. Then we use the <code>Interpreter</code> to create a <code>Runtime</code> object. After that, we can execute the program by calling <code>runtime.run()</code>.</p> <p>So far, we have only passed the code to the ChatFlow. However, soon we will learn how to define our own <code>speak</code> and <code>listen</code> functions, as well as implement our own tributary.</p>"},{"location":"tutorials/#a-parrot","title":"A Parrot","text":"<p>Our second ChatFlow program will be a parrot that simply echoes the user's input.</p> <pre><code>flow origin {\n    listen for message\n    speak message\n}\n</code></pre> <p>In our parrot program, we store the user input in the variable <code>message</code> and then speak it back to the user.</p> <p>But what if we want the parrot to continue listening and echoing until we tell it to stop? We can modify the code like this:</p> <pre><code>flow origin {\n    while true {\n        listen for message\n        speak message\n    }\n}\n</code></pre> <p>If we want the parrot to echo a specific number of times, we can alter the code like this:</p> <pre><code>flow origin {\n    variable counter = 0\n    while counter &lt; 5 {\n        listen for message\n        speak message\n        counter = counter + 1\n    }\n}\n</code></pre> <p>In this modified version, we introduce a variable called <code>counter</code> and initialize it to 0. Inside the loop, we listen for a message, speak it, and then increment the counter. The loop continues until the counter reaches 5.</p> <p>These examples demonstrate how you can use ChatFlow to create simple conversational programs. As you learn more about ChatFlow, you'll be able to define more complex behaviors and interactions.</p>"},{"location":"tutorials/#listen","title":"Listen","text":"<p>The <code>listen</code> command in ChatFlow allows the program to wait for user input and store it in a variable for further processing. It is a crucial component for creating interactive conversational experiences.</p> <p>The basic usage of <code>listen</code> involves specifying the type of input to listen for and the variable to store the received input. Here's an example:</p> <pre><code>flow origin {\n    listen for message\n    speak message\n}\n</code></pre> <p>In this example, the program listens for a <code>message</code> from the user. Once the user provides a message, it is stored in the <code>message</code> variable, and the program responds by speaking the same message back to the user. This simple pattern allows the program to act as a parrot, echoing the user's input.</p> <p>In some scenarios, it may not be desirable to indefinitely listen for user input. For instance, you may want to set a time limit for how long the program waits for input. In such cases, you can use the optional <code>for</code> parameter to specify a timeout duration.</p> <pre><code>flow origin {\n    listen for message for 5s\n    if timeout {\n        speak \"Timeout occurred.\"\n    } else {\n        speak message\n    }\n}\n</code></pre> <p>In this modified example, the program listens for a <code>message</code> for a maximum duration of 5 seconds. If no input is received within the specified time, the <code>timeout</code> condition is triggered. Inside the <code>if timeout</code> block, the program speaks \"Timeout occurred.\" If input is received within the time limit, the program proceeds to speak the stored message.</p> <p>By incorporating the <code>listen</code> command with or without a timeout, you can create interactive conversational flows that respond to user input in real-time.</p>"},{"location":"tutorials/#speak","title":"Speak","text":"<p>The <code>speak</code> command in ChatFlow is a fundamental component for generating responses and providing information to the user in a conversational manner. It allows the program to communicate with the user by speaking out messages.</p> <p>Using the <code>speak</code> command is straightforward. Simply provide the content you want the program to speak within quotation marks. Here are a few examples:</p>"},{"location":"tutorials/#literal-content","title":"Literal Content","text":"<pre><code>flow origin {\n    speak \"Hello, world!\"\n}\n</code></pre> <p>In this example, the program speaks the literal content \"Hello, world!\" to the user.</p>"},{"location":"tutorials/#variable-content","title":"Variable Content","text":"<pre><code>flow origin {\n    assign \"123456\" to content\n    speak content\n}\n</code></pre> <p>This example demonstrates how you can assign a value, such as \"123456\", to a variable called <code>content</code>. The program then speaks the value stored in the <code>content</code> variable.</p>"},{"location":"tutorials/#dynamic-content","title":"Dynamic Content","text":"<pre><code>flow origin {\n    speak \"What's your name?\"\n    listen for name\n    speak \"Hello, \" + name + \"!\"\n}\n</code></pre> <p>In this example, the program first speaks the question \"What's your name?\". It then listens for the user's input, storing it in the <code>name</code> variable. Finally, it constructs a dynamic message by combining the stored <code>name</code> with other strings and speaks the personalized greeting.</p> <p>By utilizing the <code>speak</code> command in different ways, you can create engaging and interactive conversations with your program. Whether it's providing static messages, speaking variable content, or dynamically generating responses, the <code>speak</code> command allows for effective communication in a customer service chatbot.</p>"},{"location":"tutorials/#define-custom-speak-and-listen-functions","title":"Define Custom Speak and Listen Functions","text":"<p>In ChatFlow, you have the flexibility to define your own <code>speak</code> and <code>listen</code> functions to customize the behavior of your program. </p> <p>A <code>speak</code> function takes a single parameter, which is the content it will speak. It does not require a return value. You can define your own <code>speak</code> function to add additional functionality, such as printing the number of times you speak along with the content. Here's an example:</p> <pre><code>def create_my_speak(initial=0):\n    def my_speak_function(message):\n        nonlocal initial\n        initial += 1\n        print(initial, message)\n\n    return my_speak_function\n\ndef main():\n    interpreter = Interpreter(code=code)\n    runtime = Runtime(interpreter, speak_function=create_my_speak())\n    runtime.run()\n</code></pre> <p>In this example, we define a <code>create_my_speak</code> function that returns a customized <code>speak</code> function. The <code>create_my_speak</code> function takes an optional initial value parameter and defines the <code>my_speak_function</code> nested function. The <code>my_speak_function</code> increments the <code>initial</code> value and prints the incremented value along with the message content.</p> <p>A <code>listen</code> function receives a timer value, which specifies the maximum time to wait for user input in second. If the <code>timeout</code> parameter is None, it means that no timeout is required, and the program will listen for customer input indefinitely. The <code>listen</code> function returns the content it hears, or <code>None</code> if a timeout occurs. </p> <p>The built-in <code>listen</code> function is implemented as follows:</p> <pre><code>def read_input_with_timeout(timeout=None):\n    try:\n        if timeout is None:\n            message = input()\n        else:\n            message = inputimeout(prompt='', timeout=timeout)\n        return message\n    except TimeoutOccurred:\n        return None\n</code></pre> <p>This function uses the <code>input</code> function from Python's standard library to read user input. If a <code>timeout</code> value is provided, it uses the <code>inputimeout</code> function to limit the waiting time for input. If a timeout occurs, the function returns <code>None</code>.</p> <p>By defining custom <code>speak</code> and <code>listen</code> functions, you can extend the capabilities of your ChatFlow programs and tailor them to your specific requirements.</p>"},{"location":"tutorials/#flow-control","title":"Flow Control","text":"<p>When executing a ChatFlow program, it can be visualized as traversing through different flows. Each flow represents a distinct sequence of actions and interactions within the program. As the execution progresses, the program moves from one flow to another based on the logic and control flow defined in the code.</p> <p>Think of the flows as different destinations or checkpoints in your program. The program starts at the flow origin, which serves as the starting point. From there, it engages other flows using the <code>engage</code> statement to navigate to different sections of the program.</p> <p>As the program traverses through flows, it executes the code within each flow, performing the defined actions and interacting with the user or external systems as necessary. The program may move back and forth between different flows, depending on the logic and conditions specified in the code.</p> <p>The flow-based execution model allows you to structure your program's conversations and actions in a modular and organized manner. By breaking down your program into flows, you can isolate different functionalities and make your code more manageable and maintainable.</p> <p>The flow origin serves as the entry point of the entire program. It is where the execution starts. From the flow origin, you can navigate to other flows using the <code>engage</code> statement.</p> <p>For example:</p> <pre><code>flow origin {\n    while true {\n        engage echo\n    }\n}\n\nflow echo {\n    listen for message\n    speak message\n}\n</code></pre> <p>In this example, the flow origin is defined as a loop that runs indefinitely (<code>while true</code>). Within the loop, the <code>engage</code> statement is used to step into another flow called \"echo\". This means that the program will leave the current flow and start executing the code in the \"echo\" flow. Once the code in the \"echo\" flow is completed, the program will return to the flow origin and continue with the next iteration of the loop.</p> <p>The \"echo\" flow listens for a message and then speaks the received message back to the user. It represents a specific sequence of actions that are separate from the flow origin.</p> <p>By using flows and the <code>engage</code> statement, you can create more complex conversational programs with different paths and interactions. Each flow can have its own set of actions, conditions, and responses. This allows you to structure your program in a modular and organized way, making it easier to understand and maintain.</p>"},{"location":"tutorials/#creating-a-tributary","title":"Creating a Tributary","text":"<p>In ChatFlow, you can create a tributary to extend the functionality of your conversational programs. Tributaries are external functions that can be seamlessly integrated into your ChatFlow program to perform custom operations. Let's explore an example of creating and utilizing a tributary called \"parameter_printer\":</p> <p>To create the tributary, you need to define a flow that engages it. Here's an example flow that utilizes the \"parameter_printer\" tributary:</p> <pre><code>flow origin {\n    listen for message\n    store message\n    handover parameter_printer\n}\n</code></pre> <p>In this example, the flow origin listens for a message from the user and stores it in the conversation's context. Then, it engages the \"parameter_printer\" tributary using the <code>handover</code> statement.</p> <p>Now let's define the \"parameter_printer\" tributary function in Python:</p> <pre><code>@register_tributary(\"parameter_printer\")\ndef parameter_printer(context, speak_function, listen_function):\n    para = context.get_parameter()\n    speak_function(para)\n</code></pre> <p>In this code snippet, the \"parameter_printer\" function is registered as a tributary using the <code>@register_tributary</code> decorator. The function takes three parameters: <code>context</code>, <code>speak_function</code>, and <code>listen_function</code>. The <code>context</code> parameter provides access to the conversation's context, allowing you to retrieve stored data. The <code>speak_function</code> parameter represents the function used to speak or output content to the user.</p> <p>In the \"parameter_printer\" function, the <code>context.get_parameter()</code> retrieves the stored message from the conversation's context. Then, the <code>speak_function(para)</code> outputs the retrieved message to the user.</p> <p>By creating this tributary and engaging it within the flow, you can seamlessly incorporate the custom functionality of the \"parameter_printer\" tributary into your conversational program.</p> <p>Tributaries in ChatFlow enable you to extend the capabilities of your chatbot or conversational agent by integrating custom logic and actions. They provide a flexible and modular approach to enhance the functionality and interactivity of your conversational programs.</p>"},{"location":"tutorials/#branch","title":"Branch","text":"<p>Branch control is a crucial aspect of building conversational programs in ChatFlow. It allows the program to make decisions and take different paths based on specific conditions. By using branching statements, you can create more interactive and dynamic chatbot experiences.</p> <p>To best fit the needs of a chatbot, ChatFlow provides several branching mechanisms. Let's explore some of them:</p>"},{"location":"tutorials/#matching-variable-content","title":"Matching Variable Content","text":"<p>The <code>match</code> statement is used to compare if a variable matches a specific regular expression pattern. It allows you to perform pattern matching and conditionally execute code based on the result.</p> <pre><code>flow origin {\n    listen for question for 5s\n    if timeout {\n        speak \"Timeout, conversation ended.\"\n    } else if question match \"(top up|recharge)\" {\n        engage charge_flow\n    } else {\n        speak \"Unrecognized request.\"\n        end\n    }\n}\n</code></pre> <p>In this example, the program listens for a <code>question</code> for a maximum of 5 seconds. If a timeout occurs, it speaks \"Timeout, conversation ended.\" If the <code>question</code> matches the regular expression pattern <code>(top up|recharge)</code>, it engages the <code>charge_flow</code> flow. Otherwise, it speaks \"Unrecognized request\" and ends the conversation.</p>"},{"location":"tutorials/#equality-comparison","title":"Equality Comparison","text":"<p>The <code>equals</code> statement is used to check if two values are equal. It is often used for comparing user input against expected values.</p> <pre><code>flow confirm {\n    speak \"Do you really want to charge \" + n + \" yuan? Please answer with 'yes' to proceed or 'no' to cancel.\"\n    assign false to confirmed\n    while not confirmed {\n        listen for confirmation\n        if confirmation equals \"yes\" {\n            handover charge_tributary\n            assign true to confirmed\n        } else if confirmation equals \"no\" {\n            speak \"Charge cancelled.\"\n            end\n        } else {\n            speak \"Please answer with 'yes' or 'no' only. Please repeat your choice.\"\n        }\n    }\n}\n</code></pre> <p>In this example, the program asks the user if they want to charge a specific amount. It listens for a <code>confirmation</code> and uses the <code>equals</code> statement to compare the input against \"yes\" and \"no\". If the confirmation is \"yes\", it hands over to the <code>charge_tributary</code> flow and sets <code>confirmed</code> to <code>true</code>. If the confirmation is \"no\", it speaks \"Charge cancelled\" and ends the conversation. If the confirmation is neither \"yes\" nor \"no\", it speaks a reminder message and continues listening for a valid response.</p>"},{"location":"tutorials/#timeout-handling","title":"Timeout Handling","text":"<p>ChatFlow provides a built-in variable called <code>timeout</code> that is automatically set after a <code>listen</code> statement. It allows you to handle timeouts and take appropriate actions when no input is received within a specified duration.</p> <pre><code>flow origin {\n    listen for question for 5s\n    if timeout {\n        speak \"Timeout, conversation ended.\"\n    } else {\n        // Handle user input\n    }\n}\n</code></pre> <p>In this example, the program listens for a <code>question</code> for a maximum of 5 seconds. If no input is received within the specified time, the <code>timeout</code> condition is triggered. Inside the <code>if timeout</code> block, the program speaks \"Timeout, conversation ended.\" You can use this mechanism to gracefully handle situations where the user takes too long to respond.</p> <p>By utilizing branching statements like <code>match</code>, <code>equals</code>, and <code>timeout</code>, you can create more sophisticated conversational flows in ChatFlow. These branching mechanisms enable your chatbot to make decisions based on user input and provide appropriate responses, enhancing the interactive and dynamic nature of the conversation.</p>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#chatflow.utils.a_call_function","title":"<code>a_call_function(func, *args, **kwargs)</code>  <code>async</code>","text":"<p>Calls a function, either synchronously or asynchronously, depending on the type of the function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to be called.</p> required <code>*args</code> <p>Positional arguments to be passed to the function.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to be passed to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the function call.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>async def a_call_function(func, *args, **kwargs):\n    \"\"\"\n    Calls a function, either synchronously or asynchronously, depending on the type of the function.\n\n    Args:\n        func (callable): The function to be called.\n        *args: Positional arguments to be passed to the function.\n        **kwargs: Keyword arguments to be passed to the function.\n\n    Returns:\n        The result of the function call.\n    \"\"\"\n    if inspect.iscoroutinefunction(func):\n        result = await func(*args, **kwargs)\n    else:\n        result = func(*args, **kwargs)\n\n    return result\n</code></pre>"},{"location":"utils/#chatflow.utils.a_read_input_with_timeout","title":"<code>a_read_input_with_timeout(timeout=None)</code>  <code>async</code>","text":"<p>Reads input from the user with an optional timeout.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>The timeout value in seconds. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The input message from the user if received within the timeout, None otherwise.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>async def a_read_input_with_timeout(timeout=None):\n    \"\"\"Reads input from the user with an optional timeout.\n\n    Args:\n        timeout (int, optional): The timeout value in seconds. Defaults to None.\n\n    Returns:\n        str: The input message from the user if received within the timeout, None otherwise.\n    \"\"\"\n    if timeout is None:\n        return input()\n    else:\n        timeout_task = asyncio.create_task(timeout_checker(timeout))\n        input_task = asyncio.create_task(aioconsole.ainput())\n        done, pending = await asyncio.wait({timeout_task, input_task}, return_when=asyncio.FIRST_COMPLETED)\n\n        if input_task in done:\n            message = input_task.result()\n            timeout_task.cancel()\n            return message\n        else:\n            input_task.cancel()\n            return None\n</code></pre>"},{"location":"utils/#chatflow.utils.aprint","title":"<code>aprint(*args, **kwargs)</code>  <code>async</code>","text":"<p>Prints the given arguments to the console.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>The arguments to be printed.</p> <code>()</code> <code>**kwargs</code> <p>The keyword arguments to be printed.</p> <code>{}</code> Source code in <code>chatflow\\utils.py</code> <pre><code>async def aprint(*args, **kwargs):\n    \"\"\"Prints the given arguments to the console.\n\n    Args:\n        *args: The arguments to be printed.\n        **kwargs: The keyword arguments to be printed.\n    \"\"\"\n    print(*args, **kwargs, flush=True)\n</code></pre>"},{"location":"utils/#chatflow.utils.call_function","title":"<code>call_function(func, *args, **kwargs)</code>","text":"<p>Call a function and return the result.</p> <p>This function takes a function <code>func</code> as input along with any additional arguments and keyword arguments. It checks if the function is a coroutine function and runs it using asyncio if it is. Otherwise, it simply calls the function and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to be called.</p> required <code>*args</code> <p>Additional positional arguments to be passed to the function.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of calling the function.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>def call_function(func, *args, **kwargs):\n    \"\"\"Call a function and return the result.\n\n    This function takes a function `func` as input along with any additional\n    arguments and keyword arguments. It checks if the function is a coroutine\n    function and runs it using asyncio if it is. Otherwise, it simply calls\n    the function and returns the result.\n\n    Args:\n        func (callable): The function to be called.\n        *args: Additional positional arguments to be passed to the function.\n        **kwargs: Additional keyword arguments to be passed to the function.\n\n    Returns:\n        Any: The result of calling the function.\n\n    \"\"\"\n    if inspect.iscoroutinefunction(func):\n        result = asyncio.run(func(*args, **kwargs))\n    else:\n        result = func(*args, **kwargs)\n    return result\n</code></pre>"},{"location":"utils/#chatflow.utils.format_string","title":"<code>format_string(input_str, context)</code>","text":"<p>Replace variables enclosed in curly braces with their corresponding values.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string containing variables to be replaced.</p> required <code>context</code> <code>Context</code> <p>The context dictionary containing variable-value mappings.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The input string with variables replaced by their values.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>def format_string(input_str: str, context):\n    \"\"\"Replace variables enclosed in curly braces with their corresponding values.\n\n    Args:\n        input_str (str): The input string containing variables to be replaced.\n        context (Context): The context dictionary containing variable-value mappings.\n\n    Returns:\n        (str): The input string with variables replaced by their values.\n    \"\"\"\n    start_index = input_str.find(\"{\")\n    end_index = input_str.find(\"}\")\n\n    while start_index != -1 and end_index != -1:\n        if start_index &gt; 0 and input_str[start_index - 1] == \"\\\\\":\n            start_index = input_str.find(\"{\", start_index + 1)\n            end_index = input_str.find(\"}\", end_index + 1)\n            continue\n\n        variable_name = input_str[start_index + 1: end_index]\n        value = context.get_variable(variable_name)\n        if value is not None:\n            input_str = (\n                    input_str[:start_index] + str(value) + input_str[end_index + 1:]\n            )\n\n        start_index = input_str.find(\"{\", start_index + 1)\n        end_index = input_str.find(\"}\", end_index + 1)\n\n    input_str = input_str.replace(\"\\\\{\", \"{\").replace(\"\\\\}\", \"}\")\n\n    return input_str\n</code></pre>"},{"location":"utils/#chatflow.utils.read_input_with_timeout","title":"<code>read_input_with_timeout(timeout=None)</code>","text":"<p>Reads user input with an optional timeout.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>The timeout value in seconds. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The user input if received within the timeout, None otherwise.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>def read_input_with_timeout(timeout=None):\n    \"\"\"Reads user input with an optional timeout.\n\n    Args:\n        timeout (float, optional): The timeout value in seconds. Defaults to None.\n\n    Returns:\n        str: The user input if received within the timeout, None otherwise.\n    \"\"\"\n    try:\n        if timeout is None:\n            message = input()\n        else:\n            message = inputimeout(prompt='', timeout=timeout)\n        return message\n    except TimeoutOccurred:\n        return None\n</code></pre>"}]}