{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ChatFlow","text":""},{"location":"#introduction","title":"Introduction","text":"<p>ChatFlow is a domain-specific language designed specifically for authoring conversational dialog flows, such as for chatbots and voice assistants. </p> <p>It utilizes an easy to read declarative format to define different conversation flows, the actions within them, and how they connect together. This makes it intuitive for developers to visualize and manage complex dialog logic.</p> <p>Under the hood, ChatFlow scripts are compiled into an intermediate tree representation. The included runtime engine can then interpret and execute the conversation flows based on user inputs.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Readability: ChatFlow features a highly readable grammar that enables both developers and non-technical people to understand conversation logic. It uses English-like syntax following natural language constructs, which reduces the learning curve.</p> </li> <li> <p>Integration: ChatFlow provides rich integration capabilities with external systems via Python. It allows data processing in real-time during the conversation. Users can define custom execution flows named \"tributaries\", which enable integration with anything in Python including databases, APIs and more.</p> </li> <li> <p>Interpreted: ChatFlow scripts compile into an intermediate tree format, which enables analysis, optimization and detailed debug information.</p> </li> <li> <p>Extensibility: ChatFlow provides extension points to customize execution by defining tributaries.</p> </li> <li> <p>Information Flow: ChatFlow follows one-way flow of information between flows, where data can only be passed from caller flows to callee flows. This improves modularity and hides complexity.</p> </li> </ul>"},{"location":"#learning-chatflow","title":"Learning ChatFlow","text":"<ol> <li>Quick Start</li> <li>Tutorial</li> <li>Grammar</li> <li>Concepts</li> <li>Advanced</li> </ol>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>ChatFlow owes much gratitude to the open source projects that helped make it possible.</p> <p>In particular:</p> <ul> <li>Lark     ChatFlow builds on the excellent Lark parsing toolkit for generating the abstract syntax tree from the Conversation Flow scripts. The ability to define a clean grammar and easily parse it into a manipulatable tree structure is invaluable.</li> </ul>"},{"location":"#license","title":"License","text":"<p>Lark uses the MIT license.</p>"},{"location":"BNF/","title":"BNF Definition of ChatFlow","text":"<p>Following is the BNF definition of ChatFlow:</p> <pre><code>chatflow         : flow+\n\nflow             : \"flow\" flow_name \"{\" block \"}\"\n\nblock            : statement*\n\nstatement        : if_statement\n                 | speak_statement\n                 | engage_statement\n                 | handover_statement\n                 | end_statement\n                 | listen_statement\n                 | assign_statement\n                 | while_statement\n                 | store_statement\n                 | fetch_statement\n                 | \"{\" block \"}\"\n\nstore_statement  : \"store\" value\n\nfetch_statement  : \"fetch\" variable\n\nif_statement     : \"if\" condition \"{\" block \"}\" else_statement?\n\nelse_statement   : \"else\" \"{\" block \"}\"\n                 | \"else\" if_statement\n\nwhile_statement  : \"while\" condition \"{\" block \"}\"\n\nspeak_statement  : \"speak\" str_expression\n\nstr_expression   : value ( \"+\" value )*\n\nengage_statement : \"engage\" flow_name\n\nhandover_statement : \"handover\" tributary_name\n\nend_statement    : \"end\"\n\nlisten_statement : \"listen\" \"for\" variable ( \"for\" time )?\n\nassign_statement : \"assign\" expression \"to\" variable\n\ncondition        : match_compare\n                 | equal_compare\n                 | larger_compare\n                 | less_compare\n                 | boolean\n                 | timeout\n                 | \"not\" condition\n\nlarger_compare   : expression \"larger\" \"than\" expression\n\nless_compare     : expression \"less\" \"than\" expression \n\nboolean          : TRUE\n                 | FALSE\n\nTRUE             : \"true\"\n\nFALSE            : \"false\"\n\nmatch_compare    : expression \"match\" value ( \"as\" variable )?\n\nequal_compare    : expression \"equals\" expression\n\nexpression       : term ( add_sub_operator term )*\n\nterm             : factor ( mul_div_operator factor )*\n\nfactor           : value\n                 | \"(\" expression \")\"\n\nadd_sub_operator : PLUS | MINUS\n\nmul_div_operator : TIMES | DIVIDE\n\nTIMES            : \"*\"\n\nDIVIDE           : \"/\"\n\nPLUS             : \"+\"\n\nMINUS            : \"-\"\n\nvalue            : timeout\n                 | literal\n                 | variable\n\nvariable         : identifier\n\nidentifier       : IDENTIFIER_TOKEN\n\nflow_name        : identifier\n\ntributary_name   : identifier\n\ntime             : value time_unit\n\ntime_unit        : second | minute | hour\n\nsecond           : \"s\"\n\nminute           : \"m\"\n\nhour             : \"h\"\n\ntimeout          : \"timeout\"\n\ncomparison_operator : \"equals\" | \"larger\" \"than\" | \"less\" \"than\"\n\nliteral          : STRING_LITERAL\n                 | NUMBER_LITERAL\n\nIDENTIFIER_TOKEN : /[a-zA-Z_][a-zA-Z0-9_]*/\nSTRING_LITERAL   : /\\\"(\\\\.|[^\"\\n])*\\\"/\nNUMBER_LITERAL   : SIGNED_NUMBER\n</code></pre>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright \u00a9 2023 65456u</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"lexical/","title":"Lexical Analysis","text":"<p>Lexical analysis is the first phase of the ChatFlow language processing. It involves breaking down the source code into tokens, which are the smallest meaningful units of the language. The lexer, also known as the tokenizer, scans the source code character by character and groups them into tokens based on predefined patterns and rules.</p>"},{"location":"lexical/#comment","title":"Comment","text":"<p>In ChatFlow, comments are denoted by a hash character (<code>#</code>) followed by the comment text. They can be used to provide explanations, document the code, or temporarily disable specific parts of the flow. Comments in ChatFlow are ignored by the language's interpreter and have no impact on the program's behavior or execution.</p> <p>For example:</p> <pre><code>flow origin {\n    # This is a comment explaining the purpose of this flow\n    speak \"Hello, world!\" # This line speaks a greeting message\n    # The following line is commented out to disable its execution\n    # listen for name\n}\n</code></pre> <p>In the above example, the comments provide additional information about the flow and the code. The interpreter ignores these comments, ensuring they don't affect the execution of the ChatFlow program.</p>"},{"location":"lexical/#identifiers-and-keywords","title":"Identifiers and Keywords","text":"<p>Identifiers are used to represent names in a programming language. In ChatFlow, an identifier is defined as a sequence of characters that follows a specific pattern.</p> <p>The pattern for identifiers in ChatFlow is defined using the following BNF notation:</p> <pre><code>identifier_token ::= [a-zA-Z_][a-zA-Z0-9_]*\n</code></pre> <p>An identifier must start with a letter (uppercase or lowercase) or an underscore, followed by zero or more letters, digits, or underscores. This means that identifiers can include a combination of letters (both uppercase and lowercase), digits, and underscores, but they cannot start with a digit.</p> <p>ChatFlow also has a set of reserved words or keywords that hold special meanings and cannot be used as regular identifiers. It is important to remember that these keywords must be spelled exactly as specified in the ChatFlow language and cannot be used as ordinary identifiers.</p> <p>Following are the keywords in ChatFlow:</p> <pre><code>flow        if          else        while       speak\nengage      handover    end         listen      for\nassign      to          true        false       match\nequals      larger      than        less        not\ntimeout\n</code></pre>"},{"location":"lexical/#literals","title":"Literals","text":"<p>In ChatFlow, literals are representations of constant values for certain built-in types.</p>"},{"location":"lexical/#string-literals","title":"String Literals","text":"<p>String literals in ChatFlow are represented by sequences of characters enclosed within double quotation marks (<code>\"</code>). They are used to denote textual data or strings.</p> <p>For example:</p> <pre><code>\"This is a string literal.\"\n\"Hello, world!\"\n\"12345\"\n\"Special characters: !@#$%^&amp;*()\"\n</code></pre> <p>String literals are commonly used for storing and manipulating textual data within ChatFlow scripts. They can be assigned to variables, passed as arguments to functions, concatenated, compared, and displayed as output during script execution.</p> <p>Make sure to enclose string literals within double quotation marks to indicate that they are strings.</p>"},{"location":"lexical/#number-literals","title":"Number Literals","text":"<p>Number literals in ChatFlow are used to represent numeric values, including integers and floating-point numbers.</p> <p>Here is the BNF representation of number literals in ChatFlow:</p> <pre><code>NUMBER_LITERAL ::= SIGNED_NUMBER\nSIGNED_NUMBER ::= [\"+\"|\"-\"] NUMBER\nNUMBER ::= FLOAT | INT\nFLOAT ::= INT _EXP | DECIMAL _EXP?\n_EXP ::= (\"e\"|\"E\") SIGNED_INT\nSIGNED_FLOAT ::= [\"+\"|\"-\"] FLOAT\nDECIMAL ::= INT \".\" INT? | \".\" INT\nSIGNED_INT ::= [\"+\"|\"-\"] INT\n</code></pre> <p>These rules define the syntax for representing number literals in ChatFlow, allowing for the representation of both integers and floating-point numbers.</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#install-using-pypi","title":"Install using PyPI","text":"<p>You can install ChatFlow from PyPI using the following command:</p> <pre><code>pip install chatflow\n</code></pre>"},{"location":"quick-start/#install-from-source","title":"Install from source","text":"<p>Alternatively, you can install it from the source code. First, clone the repository:</p> <pre><code>git clone https://github.com/65456u/ChatFlow.git\ncd ChatFlow\n</code></pre> <p>Then, install the required packages:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Finally, install ChatFlow:</p> <pre><code>pip install .\n</code></pre>"},{"location":"quick-start/#initializing-the-interpreter","title":"Initializing the Interpreter","text":"<p>To run a ChatFlow program, you need to create an <code>Interpreter</code> object using the ChatFlow code you have written.</p> <p>You can directly create an <code>Interpreter</code> object and pass the code as a string, like this:</p> <pre><code>from chatflow import Interpreter\n\ncode = \"\"\"\nflow origin {\n  speak \"Hello, world!\" \n}\n\"\"\"\n\ninterpreter = Interpreter(code=code)\n</code></pre> <p>Alternatively, you can create an <code>Interpreter</code> object by specifying the path to a file containing your ChatFlow code:</p> <pre><code>interpreter = Interpreter(code_path=\"hello.flow\")\n</code></pre>"},{"location":"quick-start/#creating-a-runtime-instance","title":"Creating a Runtime Instance","text":"<p>The <code>Runtime</code> class is responsible for executing the ChatFlow program.</p> <p>You can create a <code>Runtime</code> instance by passing the <code>Interpreter</code> object along with your custom <code>speak</code> and <code>listen</code> functions. If you don't provide custom functions, the runtime will use the built-in default <code>speak</code> and <code>listen</code> methods.</p> <pre><code>from chatflow import Interpreter, Runtime\n\n\ndef my_speak_function(message):\n# Custom speak function implementation\n# ...\n\ndef my_listen_function(timer):\n# Custom listen function implementation\n# ...\n\n\nruntime = Runtime(interpreter, my_speak_function, my_listen_function)\n</code></pre> <p>By providing your own <code>speak</code> and <code>listen</code> functions, you can customize the behavior of the ChatFlow program according to your needs.</p>"},{"location":"quick-start/#running-the-program","title":"Running the Program","text":"<p>To execute the ChatFlow program, simply call the <code>run()</code> method on the <code>Runtime</code> instance:</p> <pre><code>runtime.run()\n</code></pre> <p>This will start the execution of the ChatFlow program, which will proceed according to the defined flows and interactions specified in the code.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#chatflow.Interpreter","title":"<code>Interpreter</code>","text":"<p>A class that represents an interpreter for executing ChatFlow scripts.</p> <p>Parameters:</p> Name Type Description Default <code>code_path</code> <code>str</code> <p>The path to the ChatFlow script file. Defaults to None.</p> <code>None</code> <code>code</code> <code>str</code> <p>The ChatFlow script code. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>script</code> <code>str</code> <p>The ChatFlow script code.</p> <code>parser</code> <code>Lark</code> <p>The Lark parser for parsing the ChatFlow script.</p> <code>tree</code> <code>Tree</code> <p>The parsed syntax tree of the ChatFlow script.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Returns a pretty-printed representation of the parsed syntax tree.</p> Source code in <code>chatflow\\interpreter.py</code> <pre><code>class Interpreter:\n    \"\"\"\n    A class that represents an interpreter for executing ChatFlow scripts.\n\n    Args:\n        code_path (str, optional): The path to the ChatFlow script file. Defaults to None.\n        code (str, optional): The ChatFlow script code. Defaults to None.\n\n    Attributes:\n        script (str): The ChatFlow script code.\n        parser (lark.Lark): The Lark parser for parsing the ChatFlow script.\n        tree (lark.Tree): The parsed syntax tree of the ChatFlow script.\n\n    Methods:\n        __repr__(str): Returns a pretty-printed representation of the parsed syntax tree.\n\n    \"\"\"\n\n    def __init__(\n            self,\n            code_path=None,\n            code=None,\n    ):\n        if code_path:\n            with open(code_path, \"r\") as f:\n                self.script = f.read()\n        elif code:\n            self.script = code\n        self.parser = Lark(grammar, start=\"chatflow\", parser=\"lalr\")\n        self.tree = self.parser.parse(self.script)\n\n    def __repr__(self):\n        return self.tree.pretty()\n</code></pre>"},{"location":"reference/#chatflow.Runtime","title":"<code>Runtime</code>","text":"<p>Runtime for ChatFlow</p> <p>The Runtime class is responsible for executing the ChatFlow program. It manages the flow of execution, handles statements and blocks, and maintains the symbol table and context stack.</p> <p>Parameters:</p> Name Type Description Default <code>interpreter</code> <code>Interpreter</code> <p>The interpreter object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking. Defaults to print.</p> <code>None</code> <code>listen_function</code> <code>callable</code> <p>The function used for listening. Defaults to read_input_with_timeout.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>tree</code> <code>Tree</code> <p>The tree representing the ChatFlow program.</p> <code>speak_function</code> <code>callable</code> <p>The function used for speaking.</p> <code>listen_function</code> <code>callable</code> <p>The function used for listening.</p> <code>flow_dict</code> <code>dict</code> <p>A dictionary mapping flow names to their corresponding blocks.</p> <code>exit</code> <code>bool</code> <p>A boolean value indicating whether the program should exit.</p> <code>contextStack</code> <code>list</code> <p>A list of Context objects representing the context stack.</p> <p>Methods:</p> Name Description <code>init__</code> <p>Initialize the Runtime object.</p> <code>register_flow</code> <p>Register the flows defined in the ChatFlow program.</p> <code>run</code> <p>Run the ChatFlow program starting from the 'origin' flow.</p> <code>run_flow</code> <p>Run a specific flow in the ChatFlow program.</p> <code>run_block</code> <p>Run a block of statements in the ChatFlow program.</p> <code>run_statement</code> <p>Run a single statement in the ChatFlow program.</p> <code>run_if</code> <p>Run an if statement in the ChatFlow program.</p> <code>run_else</code> <p>Run an else statement in the ChatFlow program.</p> <code>run_engage</code> <p>Run an engage statement in the ChatFlow program.</p> <code>run_while</code> <p>Run a while statement in the ChatFlow program.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>class Runtime:\n    \"\"\"Runtime for ChatFlow\n\n    The Runtime class is responsible for executing the ChatFlow program. It manages the flow of execution,\n    handles statements and blocks, and maintains the symbol table and context stack.\n\n    Args:\n        interpreter (Interpreter): The interpreter object.\n        speak_function (callable, optional): The function used for speaking. Defaults to print.\n        listen_function (callable, optional): The function used for listening. Defaults to read_input_with_timeout.\n\n    Attributes:\n        tree (lark.Tree): The tree representing the ChatFlow program.\n        speak_function (callable): The function used for speaking.\n        listen_function (callable): The function used for listening.\n        flow_dict (dict): A dictionary mapping flow names to their corresponding blocks.\n        exit (bool): A boolean value indicating whether the program should exit.\n        contextStack (list): A list of Context objects representing the context stack.\n\n    Methods:\n        init__: Initialize the Runtime object.\n        register_flow: Register the flows defined in the ChatFlow program.\n        run: Run the ChatFlow program starting from the 'origin' flow.\n        run_flow: Run a specific flow in the ChatFlow program.\n        run_block: Run a block of statements in the ChatFlow program.\n        run_statement: Run a single statement in the ChatFlow program.\n        run_if: Run an if statement in the ChatFlow program.\n        run_else: Run an else statement in the ChatFlow program.\n        run_engage: Run an engage statement in the ChatFlow program.\n        run_while: Run a while statement in the ChatFlow program.\n\n    \"\"\"\n\n    def __init__(\n            self, interpreter, speak_function=None, listen_function=None, async_flag=False\n    ):\n        \"\"\"Initialize the Runtime object.\n\n        Args:\n            interpreter (Interpreter): The interpreter object.\n            speak_function (callable, optional): The function used for speaking. Defaults to print.\n            listen_function (callable, optional): The function used for listening. Defaults to read_input_with_timeout.\n\n        \"\"\"\n        self.tree = interpreter.tree\n        self.flow_dict = {}\n        self.exit = False\n        self.register_flow()\n        self.contextStack = []\n        self.async_flag = async_flag\n        if speak_function is None:\n            if async_flag:\n                self.speak_function = aprint\n            else:\n                self.speak_function = print\n        else:\n            self.speak_function = speak_function\n        if listen_function is None:\n            if async_flag:\n                self.listen_function = a_read_input_with_timeout\n            else:\n                self.listen_function = read_input_with_timeout\n        else:\n            self.listen_function = listen_function\n\n    def register_flow(self):\n        \"\"\"\n        Register the flows defined in the ChatFlow program.\n        \"\"\"\n        for flow in self.tree.children:\n            flow_name = flow.children[0].children[0].children[0]\n            block = flow.children[1]\n            self.flow_dict[flow_name] = block\n\n    def run(self):\n        self.run_flow(\"origin\")\n\n    async def arun(self):\n        await self.arun_flow(\"origin\")\n\n    async def arun_flow(self, flow_name, parameter=None):\n        \"\"\"\n        Run a specific flow in the ChatFlow program.\n\n        Args:\n            flow_name (str): The name of the flow to run.\n            parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n        \"\"\"\n        if flow_name not in self.flow_dict:\n            raise Exception(f\"Flow {flow_name} not found\")\n        tree = self.flow_dict[flow_name]\n        context = Context(parameter, tree)\n        self.contextStack.append(context)\n        await self.arun_block(tree, context)\n        self.contextStack.pop()\n\n    def run_flow(self, flow_name, parameter=None):\n        \"\"\"\n        Run a specific flow in the ChatFlow program.\n\n        Args:\n            flow_name (str): The name of the flow to run.\n            parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n        \"\"\"\n        if flow_name not in self.flow_dict:\n            raise Exception(f\"Flow {flow_name} not found\")\n        tree = self.flow_dict[flow_name]\n        context = Context(parameter, tree)\n        self.contextStack.append(context)\n        self.run_block(tree, context)\n        self.contextStack.pop()\n\n    async def arun_block(self, block, context):\n        \"\"\"\n        Run a block of statements in the ChatFlow program.\n\n        Args:\n            block (lark.Tree): The block of statements to run.\n            context (Context): The current context.\n        \"\"\"\n        context.push_scope()\n        for statement in block.children:\n            if self.exit:\n                return\n            await self.arun_statement(statement, context)\n\n    def run_block(self, block, context):\n        \"\"\"\n        Run a block of statements in the ChatFlow program.\n\n        Args:\n            block (lark.Tree): The block of statements to run.\n            context (Context): The current context.\n        \"\"\"\n        context.push_scope()\n        for statement in block.children:\n            if self.exit:\n                context.pop_scope()\n                return\n            self.run_statement(statement, context)\n        context.pop_scope()\n\n    def run_statement(self, statement, context):\n        \"\"\"\n        Run a single statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The statement to run.\n            context (Context): The current context.\n        \"\"\"\n        statement = statement.children[0]\n        state_type = statement.data\n        match state_type:\n            case \"speak_statement\":\n                run_speak(statement, context, self.speak_function)\n            case \"listen_statement\":\n                run_listen(statement, context, self.listen_function)\n            case \"if_statement\":\n                self.run_if(statement, context)\n            case \"engage_statement\":\n                self.run_engage(statement, context)\n            case \"assign_statement\":\n                run_assign(statement, context)\n            case \"end_statement\":\n                self.exit = True\n            case \"handover_statement\":\n                run_handover(\n                    statement, context, self.speak_function, self.listen_function\n                )\n            case \"while_statement\":\n                self.run_while(statement, context)\n            case \"store_statement\":\n                run_store(statement, context)\n            case \"fetch_statement\":\n                run_fetch(statement, context)\n            case \"block\":\n                self.run_block(statement, context)\n\n\n    async def arun_statement(self, statement, context):\n        \"\"\"\n        Run a single statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The statement to run.\n            context (Context): The current context.\n        \"\"\"\n        statement = statement.children[0]\n        state_type = statement.data\n        match state_type:\n            case \"speak_statement\":\n                await arun_speak(statement, context, self.speak_function)\n            case \"listen_statement\":\n                await arun_listen(statement, context, self.listen_function)\n            case \"if_statement\":\n                await self.arun_if(statement, context)\n            case \"engage_statement\":\n                await self.arun_engage(statement, context)\n            case \"assign_statement\":\n                run_assign(statement, context)\n            case \"end_statement\":\n                self.exit = True\n            case \"handover_statement\":\n                await arun_handover(\n                    statement, context, self.speak_function, self.listen_function\n                )\n            case \"while_statement\":\n                await self.arun_while(statement, context)\n            case \"store_statement\":\n                run_store(statement, context)\n            case \"block\":\n                await self.arun_block(statement, context)\n\n    async def arun_if(self, statement, context):\n        \"\"\"\n        Run an if statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The if statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        result = get_condition(condition, context)\n        if result:\n            await self.arun_block(statement.children[1], context)\n        else:\n            if len(statement.children) == 3:\n                await self.arun_else(statement.children[2], context)\n\n    def run_if(self, statement, context):\n        \"\"\"\n        Run an if statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The if statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        result = get_condition(condition, context)\n        if result:\n            self.run_block(statement.children[1], context)\n        else:\n            if len(statement.children) == 3:\n                self.run_else(statement.children[2], context)\n\n    async def arun_else(self, statement, context):\n        \"\"\"\n        Run an else statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The else statement to run.\n            context (Context): The current context.\n        \"\"\"\n        else_statement = statement.children[0]\n        match else_statement.data:\n            case \"block\":\n                await self.arun_block(else_statement, context)\n            case \"if_statement\":\n                await self.arun_if(else_statement, context)\n\n    def run_else(self, statement, context):\n        \"\"\"\n        Run an else statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The else statement to run.\n            context (Context): The current context.\n        \"\"\"\n        else_statement = statement.children[0]\n        match else_statement.data:\n            case \"block\":\n                self.run_block(else_statement, context)\n            case \"if_statement\":\n                self.run_if(else_statement, context)\n\n    async def arun_engage(self, statement, context):\n        \"\"\"\n        Run an engage statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The engage statement to run.\n            context (Context): The current context.\n        \"\"\"\n        flow_name = get_flow_name(statement.children[0])\n        await self.arun_flow(flow_name, context.get_parameter())\n\n    def run_engage(self, statement, context):\n        \"\"\"\n        Run an engage statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The engage statement to run.\n            context (Context): The current context.\n        \"\"\"\n        flow_name = get_flow_name(statement.children[0])\n        self.run_flow(flow_name, context.get_parameter())\n\n    async def arun_while(self, statement, context):\n        \"\"\"\n        Run a while statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The while statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        while get_condition(condition, context):\n            await self.arun_block(statement.children[1], context)\n\n    def run_while(self, statement, context):\n        \"\"\"\n        Run a while statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The while statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        while get_condition(condition, context):\n            self.run_block(statement.children[1], context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.__init__","title":"<code>__init__(interpreter, speak_function=None, listen_function=None, async_flag=False)</code>","text":"<p>Initialize the Runtime object.</p> <p>Parameters:</p> Name Type Description Default <code>interpreter</code> <code>Interpreter</code> <p>The interpreter object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking. Defaults to print.</p> <code>None</code> <code>listen_function</code> <code>callable</code> <p>The function used for listening. Defaults to read_input_with_timeout.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>def __init__(\n        self, interpreter, speak_function=None, listen_function=None, async_flag=False\n):\n    \"\"\"Initialize the Runtime object.\n\n    Args:\n        interpreter (Interpreter): The interpreter object.\n        speak_function (callable, optional): The function used for speaking. Defaults to print.\n        listen_function (callable, optional): The function used for listening. Defaults to read_input_with_timeout.\n\n    \"\"\"\n    self.tree = interpreter.tree\n    self.flow_dict = {}\n    self.exit = False\n    self.register_flow()\n    self.contextStack = []\n    self.async_flag = async_flag\n    if speak_function is None:\n        if async_flag:\n            self.speak_function = aprint\n        else:\n            self.speak_function = print\n    else:\n        self.speak_function = speak_function\n    if listen_function is None:\n        if async_flag:\n            self.listen_function = a_read_input_with_timeout\n        else:\n            self.listen_function = read_input_with_timeout\n    else:\n        self.listen_function = listen_function\n</code></pre>"},{"location":"reference/#chatflow.Runtime.arun_block","title":"<code>arun_block(block, context)</code>  <code>async</code>","text":"<p>Run a block of statements in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Tree</code> <p>The block of statements to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_block(self, block, context):\n    \"\"\"\n    Run a block of statements in the ChatFlow program.\n\n    Args:\n        block (lark.Tree): The block of statements to run.\n        context (Context): The current context.\n    \"\"\"\n    context.push_scope()\n    for statement in block.children:\n        if self.exit:\n            return\n        await self.arun_statement(statement, context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.arun_else","title":"<code>arun_else(statement, context)</code>  <code>async</code>","text":"<p>Run an else statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The else statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_else(self, statement, context):\n    \"\"\"\n    Run an else statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The else statement to run.\n        context (Context): The current context.\n    \"\"\"\n    else_statement = statement.children[0]\n    match else_statement.data:\n        case \"block\":\n            await self.arun_block(else_statement, context)\n        case \"if_statement\":\n            await self.arun_if(else_statement, context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.arun_engage","title":"<code>arun_engage(statement, context)</code>  <code>async</code>","text":"<p>Run an engage statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The engage statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_engage(self, statement, context):\n    \"\"\"\n    Run an engage statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The engage statement to run.\n        context (Context): The current context.\n    \"\"\"\n    flow_name = get_flow_name(statement.children[0])\n    await self.arun_flow(flow_name, context.get_parameter())\n</code></pre>"},{"location":"reference/#chatflow.Runtime.arun_flow","title":"<code>arun_flow(flow_name, parameter=None)</code>  <code>async</code>","text":"<p>Run a specific flow in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>flow_name</code> <code>str</code> <p>The name of the flow to run.</p> required <code>parameter</code> <code>any</code> <p>The parameter to pass to the flow. Defaults to None.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_flow(self, flow_name, parameter=None):\n    \"\"\"\n    Run a specific flow in the ChatFlow program.\n\n    Args:\n        flow_name (str): The name of the flow to run.\n        parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n    \"\"\"\n    if flow_name not in self.flow_dict:\n        raise Exception(f\"Flow {flow_name} not found\")\n    tree = self.flow_dict[flow_name]\n    context = Context(parameter, tree)\n    self.contextStack.append(context)\n    await self.arun_block(tree, context)\n    self.contextStack.pop()\n</code></pre>"},{"location":"reference/#chatflow.Runtime.arun_if","title":"<code>arun_if(statement, context)</code>  <code>async</code>","text":"<p>Run an if statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The if statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_if(self, statement, context):\n    \"\"\"\n    Run an if statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The if statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    result = get_condition(condition, context)\n    if result:\n        await self.arun_block(statement.children[1], context)\n    else:\n        if len(statement.children) == 3:\n            await self.arun_else(statement.children[2], context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.arun_statement","title":"<code>arun_statement(statement, context)</code>  <code>async</code>","text":"<p>Run a single statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_statement(self, statement, context):\n    \"\"\"\n    Run a single statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The statement to run.\n        context (Context): The current context.\n    \"\"\"\n    statement = statement.children[0]\n    state_type = statement.data\n    match state_type:\n        case \"speak_statement\":\n            await arun_speak(statement, context, self.speak_function)\n        case \"listen_statement\":\n            await arun_listen(statement, context, self.listen_function)\n        case \"if_statement\":\n            await self.arun_if(statement, context)\n        case \"engage_statement\":\n            await self.arun_engage(statement, context)\n        case \"assign_statement\":\n            run_assign(statement, context)\n        case \"end_statement\":\n            self.exit = True\n        case \"handover_statement\":\n            await arun_handover(\n                statement, context, self.speak_function, self.listen_function\n            )\n        case \"while_statement\":\n            await self.arun_while(statement, context)\n        case \"store_statement\":\n            run_store(statement, context)\n        case \"block\":\n            await self.arun_block(statement, context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.arun_while","title":"<code>arun_while(statement, context)</code>  <code>async</code>","text":"<p>Run a while statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The while statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_while(self, statement, context):\n    \"\"\"\n    Run a while statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The while statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    while get_condition(condition, context):\n        await self.arun_block(statement.children[1], context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.register_flow","title":"<code>register_flow()</code>","text":"<p>Register the flows defined in the ChatFlow program.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>def register_flow(self):\n    \"\"\"\n    Register the flows defined in the ChatFlow program.\n    \"\"\"\n    for flow in self.tree.children:\n        flow_name = flow.children[0].children[0].children[0]\n        block = flow.children[1]\n        self.flow_dict[flow_name] = block\n</code></pre>"},{"location":"reference/#chatflow.Runtime.run_block","title":"<code>run_block(block, context)</code>","text":"<p>Run a block of statements in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Tree</code> <p>The block of statements to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_block(self, block, context):\n    \"\"\"\n    Run a block of statements in the ChatFlow program.\n\n    Args:\n        block (lark.Tree): The block of statements to run.\n        context (Context): The current context.\n    \"\"\"\n    context.push_scope()\n    for statement in block.children:\n        if self.exit:\n            context.pop_scope()\n            return\n        self.run_statement(statement, context)\n    context.pop_scope()\n</code></pre>"},{"location":"reference/#chatflow.Runtime.run_else","title":"<code>run_else(statement, context)</code>","text":"<p>Run an else statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The else statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_else(self, statement, context):\n    \"\"\"\n    Run an else statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The else statement to run.\n        context (Context): The current context.\n    \"\"\"\n    else_statement = statement.children[0]\n    match else_statement.data:\n        case \"block\":\n            self.run_block(else_statement, context)\n        case \"if_statement\":\n            self.run_if(else_statement, context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.run_engage","title":"<code>run_engage(statement, context)</code>","text":"<p>Run an engage statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The engage statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_engage(self, statement, context):\n    \"\"\"\n    Run an engage statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The engage statement to run.\n        context (Context): The current context.\n    \"\"\"\n    flow_name = get_flow_name(statement.children[0])\n    self.run_flow(flow_name, context.get_parameter())\n</code></pre>"},{"location":"reference/#chatflow.Runtime.run_flow","title":"<code>run_flow(flow_name, parameter=None)</code>","text":"<p>Run a specific flow in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>flow_name</code> <code>str</code> <p>The name of the flow to run.</p> required <code>parameter</code> <code>any</code> <p>The parameter to pass to the flow. Defaults to None.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_flow(self, flow_name, parameter=None):\n    \"\"\"\n    Run a specific flow in the ChatFlow program.\n\n    Args:\n        flow_name (str): The name of the flow to run.\n        parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n    \"\"\"\n    if flow_name not in self.flow_dict:\n        raise Exception(f\"Flow {flow_name} not found\")\n    tree = self.flow_dict[flow_name]\n    context = Context(parameter, tree)\n    self.contextStack.append(context)\n    self.run_block(tree, context)\n    self.contextStack.pop()\n</code></pre>"},{"location":"reference/#chatflow.Runtime.run_if","title":"<code>run_if(statement, context)</code>","text":"<p>Run an if statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The if statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_if(self, statement, context):\n    \"\"\"\n    Run an if statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The if statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    result = get_condition(condition, context)\n    if result:\n        self.run_block(statement.children[1], context)\n    else:\n        if len(statement.children) == 3:\n            self.run_else(statement.children[2], context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.run_statement","title":"<code>run_statement(statement, context)</code>","text":"<p>Run a single statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_statement(self, statement, context):\n    \"\"\"\n    Run a single statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The statement to run.\n        context (Context): The current context.\n    \"\"\"\n    statement = statement.children[0]\n    state_type = statement.data\n    match state_type:\n        case \"speak_statement\":\n            run_speak(statement, context, self.speak_function)\n        case \"listen_statement\":\n            run_listen(statement, context, self.listen_function)\n        case \"if_statement\":\n            self.run_if(statement, context)\n        case \"engage_statement\":\n            self.run_engage(statement, context)\n        case \"assign_statement\":\n            run_assign(statement, context)\n        case \"end_statement\":\n            self.exit = True\n        case \"handover_statement\":\n            run_handover(\n                statement, context, self.speak_function, self.listen_function\n            )\n        case \"while_statement\":\n            self.run_while(statement, context)\n        case \"store_statement\":\n            run_store(statement, context)\n        case \"fetch_statement\":\n            run_fetch(statement, context)\n        case \"block\":\n            self.run_block(statement, context)\n</code></pre>"},{"location":"reference/#chatflow.Runtime.run_while","title":"<code>run_while(statement, context)</code>","text":"<p>Run a while statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The while statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_while(self, statement, context):\n    \"\"\"\n    Run a while statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The while statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    while get_condition(condition, context):\n        self.run_block(statement.children[1], context)\n</code></pre>"},{"location":"reference/#chatflow.register_tributary","title":"<code>register_tributary(tributary_name)</code>","text":"<p>Register a tributary function to be used in ChatFlow</p> <p>Parameters:</p> Name Type Description Default <code>tributary_name</code> <code>str</code> <p>The name of the tributary to be registered</p> required <p>Returns:</p> Name Type Description <code>function</code> <code>callable</code> <p>The decorated function</p> Source code in <code>chatflow\\tributary.py</code> <pre><code>def register_tributary(tributary_name):\n    \"\"\"Register a tributary function to be used in ChatFlow\n\n    Args:\n        tributary_name (str): The name of the tributary to be registered\n\n    Returns:\n        function(callable): The decorated function\n\n    \"\"\"\n\n    def decorator(func):\n        tributary_dict[tributary_name] = func\n        return func\n\n    return decorator\n</code></pre>"},{"location":"statement/","title":"Statements","text":""},{"location":"statement/#statements","title":"Statements","text":"<p>The ChatFlow statement consists of various types of statements that control the conversation flow and interact with the user.</p>"},{"location":"statement/#if-statement","title":"If Statement","text":"<p>The if statement in ChatFlow allows you to introduce conditional branching within your conversation flow. It enables you to make decisions based on specific conditions and execute different sets of statements accordingly.</p> <p>The syntax for the if statement in ChatFlow is as follows:</p> <pre><code>if_statement     ::= \"if\" condition \"{\" block \"}\" (else_statement)?\nelse_statement   ::= \"else\" \"{\" block \"}\"\n                 | \"else\" if_statement\n</code></pre> <p>In this syntax, the \"condition\" represents an expression that evaluates to a Boolean value. If the condition is true, the statements within the first block are executed. Optionally, an \"else\" block can be included, which contains statements that are executed when the condition is false. The \"else\" block can either be a block of statements or another if statement, allowing for nested conditional logic.</p>"},{"location":"statement/#speak-statement","title":"Speak Statement","text":"<p>The speak statement is used to send a message or response to the user during the conversation. It allows you to provide information, ask questions, or guide the user through the interaction.</p> <p>The syntax for the speak statement in ChatFlow is as follows:</p> <pre><code>speak_statement  ::= \"speak\" str_expression\nstr_expression   ::= value (\"+\" value)*\n</code></pre> <p>In this syntax, the \"str_expression\" represents the content of the message to be spoken. It can be a concatenation of multiple values using the \"+\" operator. The values can be string literals, variable names, or expressions that evaluate to a string.</p>"},{"location":"statement/#engage-statement","title":"Engage Statement","text":"<p>The engage statement in ChatFlow allows you to transition from the current flow to another flow. It enables you to modularize your conversation and organize it into separate flows.</p> <p>The syntax for the engage statement in ChatFlow is as follows:</p> <pre><code>engage_statement ::= \"engage\" flow_name\n</code></pre> <p>In this syntax, the \"flow_name\" represents the name of the flow that you want to engage with. It allows you to initiate another flow within the current flow, continuing the conversation in a different context.</p>"},{"location":"statement/#handover-statement","title":"Handover Statement","text":"<p>The handover statement in ChatFlow is used to transfer the conversation to another tributary, which is an user-defined external program. It allows you to hand over the conversation to a different system or service for further processing.</p> <pre><code>handover_statement ::= \"handover\" tributary_name\n</code></pre>"},{"location":"statement/#end-statement","title":"End Statement","text":"<p>The end statement in ChatFlow is used to stop the execution of the entire program. It terminates the conversation and exits the ChatFlow program.</p> <pre><code>end_statement    ::= \"end\"\n</code></pre>"},{"location":"statement/#listen-statement","title":"Listen Statement","text":"<p>The listen statement in ChatFlow is used to listen for user input during the conversation. It allows the ChatFlow program to wait for the user to provide a response before continuing with the execution. If timeout is reached, the timeout variable in the context if automatically set.</p> <pre><code>listen_statement ::= \"listen\" \"for\" variable (\"for\" time)?\n</code></pre>"},{"location":"statement/#assign-statement","title":"Assign Statement","text":"<p>The assign statement in ChatFlow is used to assign a value to a variable. It allows you to store and manipulate data within the ChatFlow program.</p> <pre><code>assign_statement ::= \"assign\" expression \"to\" variable\n</code></pre>"},{"location":"statement/#while-statement","title":"While Statement","text":"<p>The while statement in ChatFlow allows you to create a loop that executes a block of statements repeatedly as long as a specific condition is true.</p> <pre><code>while_statement  ::= \"while\" condition \"{\" block \"}\"\n</code></pre>"},{"location":"statement/#store-statement","title":"Store Statement","text":"<p>The store statement in ChatFlow is used to store a value in the parameter within the context, enabling the passing of information from one flow to another flow or a tributary. It allows you to store data that can be accessed and utilized across different parts of the conversation.</p> <pre><code>store_statement  ::= \"store\" value\n</code></pre> <p>In this syntax, the \"value\" represents the data or value that you want to store in the parameter within the context. By utilizing the store statement, you can preserve and retrieve information as needed throughout the conversation. This feature facilitates seamless information sharing and enhances the flexibility and functionality of your ChatFlow program.</p>"},{"location":"statement/#fetch-statement","title":"Fetch Statement","text":"<p>The fetch statement in ChatFlow is used to retrieve the stored value from the parameter within the context. It allows you to access data that has been previously stored using the store statement.</p> <pre><code>fetch_statement  ::= \"fetch\" value\n</code></pre> <p>In this syntax, the \"value\" represents the data or value that you want to retrieve from the parameter within the context. By utilizing the fetch statement, you can access stored information and use it in your conversation flow. This enables you to leverage previously stored data and incorporate it into your ChatFlow program in a dynamic and customized manner.</p>"},{"location":"structure/","title":"Structure of ChatFlow Program","text":"<p>The structure of a ChatFlow program is based on three key concepts: flow, block,statement, and tributary.</p>"},{"location":"structure/#flow","title":"Flow","text":"<p>A flow in ChatFlow represents a sequence of steps or actions that define the conversational logic. It defines the structure and flow of the conversation between the user and the ChatFlow program. A flow is defined using the keyword \"flow\" followed by a flow name and enclosed within curly braces.</p> <p>The BNF (Backus-Naur Form) representation of a flow in ChatFlow is as follows:</p> <pre><code>flow             ::= \"flow\" flow_name \"{\" block \"}\"\nflow_name        ::= identifier\n</code></pre> <p>In this syntax, the \"flow_name\" is a user-defined identifier that uniquely identifies the flow within the program. It should be chosen to reflect the purpose or content of the flow. The \"block\" represents a collection of statements that define the actions and interactions within the flow. These statements can include if statements, speak statements, engage statements, handover statements, and more.</p> <p>To transition from one flow to another, you can use the engage statement. The engage statement allows you to initiate another flow within the current flow, enabling you to create complex conversation flows and modularize your ChatFlow program. </p> <p>To engage a specific flow, you use the following syntax:</p> <pre><code>engage flow_name\n</code></pre> <p>Here, \"flow_name\" refers to the name of the flow you want to transition to. By using the engage statement, you can seamlessly navigate between different flows and create dynamic and interactive conversations for your users.</p>"},{"location":"structure/#block","title":"Block","text":"<p>A block in ChatFlow is a series of statements grouped together within a flow. It represents a section of code that is executed sequentially. A block is enclosed within curly braces and can contain multiple statements.</p> <p>The definition of a block in ChatFlow can be represented as:</p> <pre><code>block            ::= statement*\n</code></pre> <p>In this representation, \"statement*\" denotes zero or more statements within the block. Each statement represents a specific action or instruction within the flow.</p> <p>When you create a block, any variables declared within that block are only accessible within that block's scope. They are not visible outside of the block or in other blocks within the flow.</p> <p>Here's an example that demonstrates the usage of a block in ChatFlow:</p> <pre><code>flow origin {\n    # Variables declared within the origin flow block\n    assign \"John\" to name\n    assign 25 to age\n\n    # Start of a block\n    {\n        # Variable declared within the block\n        assign \"Smith\" to lastName\n\n        speak \"Full name: \" + name + \" \" + lastName\n        speak \"Age: \" + age\n    }  # End of the block\n\n    # The following line will cause an error because lastName is not accessible here\n    speak \"Last name: \" + lastName\n}\n</code></pre> <p>In the above example, the block is defined within the <code>origin</code> flow. Inside the block, a variable <code>lastName</code> is declared, and the code within the block can access the <code>name</code>, <code>age</code>, and <code>lastName</code> variables. However, outside the block, the <code>lastName</code> variable is not accessible, and attempting to access it will result in an error.</p> <p>By using blocks, you can control the scope of variables and organize your code into logical sections. This allows for better code readability and prevents variable name conflicts between different parts of your ChatFlow program.</p>"},{"location":"structure/#statement","title":"Statement","text":"<p>A statement in ChatFlow is a basic unit of code that represents an action or instruction within a flow. It performs a specific task or interaction with the user. ChatFlow supports various types of statements, including conditionals, speaking to the user, engaging with other flows, listening for user input, assigning values to variables, looping constructs, and more.</p> <p>The BNF representation of a statement in ChatFlow can be defined as:</p> <pre><code>statement        ::= if_statement\n                   | speak_statement\n                   | engage_statement\n                   | handover_statement\n                   | end_statement\n                   | listen_statement\n                   | assign_statement\n                   | while_statement\n                   | store_statement\n                   | \"{\" block \"}\"\n</code></pre> <p>Each statement type has its own syntax and purpose within the ChatFlow program.</p> <p>For more detailed information on statements, please refer to statement.</p>"},{"location":"structure/#tributary","title":"Tributary","text":"<p>Tributaries are external functions that can be seamlessly integrated into your ChatFlow program to perform custom operations or interact with external services. They allow you to extend the functionality of ChatFlow by incorporating specific logic or functionality that is not provided by the built-in statements.</p> <p>To define a tributary in ChatFlow, you can use the <code>@register_tributary</code> decorator followed by the tributary name and the function definition. The function should accept the <code>context</code>, <code>speak_function</code>, and <code>listen_function</code> as parameters. The <code>context</code> parameter provides access to the ChatFlow context, allowing you to retrieve or modify parameters and other contextual information. The <code>speak_function</code> is used to send messages or responses to the user, while the <code>listen_function</code> is used to listen for user input.</p> <p>Here's an example of defining a tributary named \"print_parameter\" using Python:</p> <pre><code>@register_tributary(\"print_parameter\")\ndef display(context, speak_function, listen_function):\n    print(context.get_parameter())\n</code></pre> <p>In this example, the <code>display</code> function is registered as the \"print_parameter\" tributary. Within the function, you have access to the ChatFlow context through the <code>context</code> parameter. You can use the <code>speak_function</code> to send messages or responses to the user, and the <code>listen_function</code> to listen for user input. In this case, the function simply prints the value of a parameter using the <code>get_parameter()</code> method of the context.</p> <p>To use a tributary within your ChatFlow program, you can use the <code>handover</code> statement followed by the name of the tributary. This allows you to transfer the conversation to the specified tributary for further processing.</p> <p>Here's an example of using the <code>handover</code> statement to invoke the \"display\" tributary:</p> <pre><code>handover print_parameter\n</code></pre> <p>In this example, the <code>print_parameter</code> statement transfers the conversation to the \"display\" tributary, allowing it to perform its specific logic or functionality. Once the tributary has completed its task, the control can be handed back to the ChatFlow program.</p> <p>By leveraging tributaries, you can integrate external functions or services seamlessly into your ChatFlow program, enhancing its capabilities and enabling custom operations based on your specific requirements.</p>"},{"location":"tutorials/","title":"Learning ChatFlow","text":""},{"location":"tutorials/#the-first-chatflow-program","title":"The First ChatFlow Program","text":"<p>Let's write our first ChatFlow program that says \"hello\" to the world.</p> <pre><code>flow origin {\n  speak \"Hello, world!\" \n}\n</code></pre> <p>To run this program, you can use the following Python code:</p> <pre><code>from chatflow import Interpreter, Runtime\n\ncode = \"\"\"\nflow origin {\n  speak \"Hello, world!\" \n}\n\"\"\"\n\ninterpreter = Interpreter(code=code)\nruntime = Runtime(interpreter)\nruntime.run() \n</code></pre> <p>The current program only has one flow called \"origin,\" which serves as the entry point of the entire ChatFlow program.</p> <p>We first create an <code>Interpreter</code> object using the provided code. Then we use the <code>Interpreter</code> to create a <code>Runtime</code> object. After that, we can execute the program by calling <code>runtime.run()</code>.</p> <p>So far, we have only passed the code to the ChatFlow. However, soon we will learn how to define our own <code>speak</code> and <code>listen</code> functions, as well as implement our own tributary.</p>"},{"location":"tutorials/#a-parrot","title":"A Parrot","text":"<p>Our second ChatFlow program will be a parrot that simply echoes the user's input.</p> <pre><code>flow origin {\n    listen for message\n    speak message\n}\n</code></pre> <p>In our parrot program, we store the user input in the variable <code>message</code> and then speak it back to the user.</p> <p>But what if we want the parrot to continue listening and echoing until we tell it to stop? We can modify the code like this:</p> <pre><code>flow origin {\n    while true {\n        listen for message\n        speak message\n    }\n}\n</code></pre> <p>If we want the parrot to echo a specific number of times, we can alter the code like this:</p> <pre><code>flow origin {\n    variable counter = 0\n    while counter &lt; 5 {\n        listen for message\n        speak message\n        counter = counter + 1\n    }\n}\n</code></pre> <p>In this modified version, we introduce a variable called <code>counter</code> and initialize it to 0. Inside the loop, we listen for a message, speak it, and then increment the counter. The loop continues until the counter reaches 5.</p> <p>These examples demonstrate how you can use ChatFlow to create simple conversational programs. As you learn more about ChatFlow, you'll be able to define more complex behaviors and interactions.</p>"},{"location":"tutorials/#listen","title":"Listen","text":"<p>The <code>listen</code> command in ChatFlow allows the program to wait for user input and store it in a variable for further processing. It is a crucial component for creating interactive conversational experiences.</p> <p>The basic usage of <code>listen</code> involves specifying the type of input to listen for and the variable to store the received input. Here's an example:</p> <pre><code>flow origin {\n    listen for message\n    speak message\n}\n</code></pre> <p>In this example, the program listens for a <code>message</code> from the user. Once the user provides a message, it is stored in the <code>message</code> variable, and the program responds by speaking the same message back to the user. This simple pattern allows the program to act as a parrot, echoing the user's input.</p> <p>In some scenarios, it may not be desirable to indefinitely listen for user input. For instance, you may want to set a time limit for how long the program waits for input. In such cases, you can use the optional <code>for</code> parameter to specify a timeout duration.</p> <pre><code>flow origin {\n    listen for message for 5s\n    if timeout {\n        speak \"Timeout occurred.\"\n    } else {\n        speak message\n    }\n}\n</code></pre> <p>In this modified example, the program listens for a <code>message</code> for a maximum duration of 5 seconds. If no input is received within the specified time, the <code>timeout</code> condition is triggered. Inside the <code>if timeout</code> block, the program speaks \"Timeout occurred.\" If input is received within the time limit, the program proceeds to speak the stored message.</p> <p>By incorporating the <code>listen</code> command with or without a timeout, you can create interactive conversational flows that respond to user input in real-time.</p>"},{"location":"tutorials/#speak","title":"Speak","text":"<p>The <code>speak</code> command in ChatFlow is a fundamental component for generating responses and providing information to the user in a conversational manner. It allows the program to communicate with the user by speaking out messages.</p> <p>Using the <code>speak</code> command is straightforward. Simply provide the content you want the program to speak within quotation marks. Here are a few examples:</p>"},{"location":"tutorials/#literal-content","title":"Literal Content","text":"<pre><code>flow origin {\n    speak \"Hello, world!\"\n}\n</code></pre> <p>In this example, the program speaks the literal content \"Hello, world!\" to the user.</p>"},{"location":"tutorials/#variable-content","title":"Variable Content","text":"<pre><code>flow origin {\n    assign \"123456\" to content\n    speak content\n}\n</code></pre> <p>This example demonstrates how you can assign a value, such as \"123456\", to a variable called <code>content</code>. The program then speaks the value stored in the <code>content</code> variable.</p>"},{"location":"tutorials/#dynamic-content","title":"Dynamic Content","text":"<pre><code>flow origin {\n    speak \"What's your name?\"\n    listen for name\n    speak \"Hello, \" + name + \"!\"\n}\n</code></pre> <p>In this example, the program first speaks the question \"What's your name?\". It then listens for the user's input, storing it in the <code>name</code> variable. Finally, it constructs a dynamic message by combining the stored <code>name</code> with other strings and speaks the personalized greeting.</p> <p>By utilizing the <code>speak</code> command in different ways, you can create engaging and interactive conversations with your program. Whether it's providing static messages, speaking variable content, or dynamically generating responses, the <code>speak</code> command allows for effective communication in a customer service chatbot.</p>"},{"location":"tutorials/#define-custom-speak-and-listen-functions","title":"Define Custom Speak and Listen Functions","text":"<p>In ChatFlow, you have the flexibility to define your own <code>speak</code> and <code>listen</code> functions to customize the behavior of your program. </p> <p>A <code>speak</code> function takes a single parameter, which is the content it will speak. It does not require a return value. You can define your own <code>speak</code> function to add additional functionality, such as printing the number of times you speak along with the content. Here's an example:</p> <pre><code>def create_my_speak(initial=0):\n    def my_speak_function(message):\n        nonlocal initial\n        initial += 1\n        print(initial, message)\n\n    return my_speak_function\n\ndef main():\n    interpreter = Interpreter(code=code)\n    runtime = Runtime(interpreter, speak_function=create_my_speak())\n    runtime.run()\n</code></pre> <p>In this example, we define a <code>create_my_speak</code> function that returns a customized <code>speak</code> function. The <code>create_my_speak</code> function takes an optional initial value parameter and defines the <code>my_speak_function</code> nested function. The <code>my_speak_function</code> increments the <code>initial</code> value and prints the incremented value along with the message content.</p> <p>A <code>listen</code> function receives a timer value, which specifies the maximum time to wait for user input in second. If the <code>timeout</code> parameter is None, it means that no timeout is required, and the program will listen for customer input indefinitely. The <code>listen</code> function returns the content it hears, or <code>None</code> if a timeout occurs. </p> <p>The built-in <code>listen</code> function is implemented as follows:</p> <pre><code>def read_input_with_timeout(timeout=None):\n    try:\n        if timeout is None:\n            message = input()\n        else:\n            message = inputimeout(prompt='', timeout=timeout)\n        return message\n    except TimeoutOccurred:\n        return None\n</code></pre> <p>This function uses the <code>input</code> function from Python's standard library to read user input. If a <code>timeout</code> value is provided, it uses the <code>inputimeout</code> function to limit the waiting time for input. If a timeout occurs, the function returns <code>None</code>.</p> <p>By defining custom <code>speak</code> and <code>listen</code> functions, you can extend the capabilities of your ChatFlow programs and tailor them to your specific requirements.</p>"},{"location":"tutorials/#flow-control","title":"Flow Control","text":"<p>When executing a ChatFlow program, it can be visualized as traversing through different flows. Each flow represents a distinct sequence of actions and interactions within the program. As the execution progresses, the program moves from one flow to another based on the logic and control flow defined in the code.</p> <p>Think of the flows as different destinations or checkpoints in your program. The program starts at the flow origin, which serves as the starting point. From there, it engages other flows using the <code>engage</code> statement to navigate to different sections of the program.</p> <p>As the program traverses through flows, it executes the code within each flow, performing the defined actions and interacting with the user or external systems as necessary. The program may move back and forth between different flows, depending on the logic and conditions specified in the code.</p> <p>The flow-based execution model allows you to structure your program's conversations and actions in a modular and organized manner. By breaking down your program into flows, you can isolate different functionalities and make your code more manageable and maintainable.</p> <p>The flow origin serves as the entry point of the entire program. It is where the execution starts. From the flow origin, you can navigate to other flows using the <code>engage</code> statement.</p> <p>For example:</p> <pre><code>flow origin {\n    while true {\n        engage echo\n    }\n}\n\nflow echo {\n    listen for message\n    speak message\n}\n</code></pre> <p>In this example, the flow origin is defined as a loop that runs indefinitely (<code>while true</code>). Within the loop, the <code>engage</code> statement is used to step into another flow called \"echo\". This means that the program will leave the current flow and start executing the code in the \"echo\" flow. Once the code in the \"echo\" flow is completed, the program will return to the flow origin and continue with the next iteration of the loop.</p> <p>The \"echo\" flow listens for a message and then speaks the received message back to the user. It represents a specific sequence of actions that are separate from the flow origin.</p> <p>By using flows and the <code>engage</code> statement, you can create more complex conversational programs with different paths and interactions. Each flow can have its own set of actions, conditions, and responses. This allows you to structure your program in a modular and organized way, making it easier to understand and maintain.</p>"},{"location":"tutorials/#creating-a-tributary","title":"Creating a Tributary","text":"<p>In ChatFlow, you can create a tributary to extend the functionality of your conversational programs. Tributaries are external functions that can be seamlessly integrated into your ChatFlow program to perform custom operations. Let's explore an example of creating and utilizing a tributary called \"parameter_printer\":</p> <p>To create the tributary, you need to define a flow that engages it. Here's an example flow that utilizes the \"parameter_printer\" tributary:</p> <pre><code>flow origin {\n    listen for message\n    store message\n    handover parameter_printer\n}\n</code></pre> <p>In this example, the flow origin listens for a message from the user and stores it in the conversation's context. Then, it engages the \"parameter_printer\" tributary using the <code>handover</code> statement.</p> <p>Now let's define the \"parameter_printer\" tributary function in Python:</p> <pre><code>@register_tributary(\"parameter_printer\")\ndef parameter_printer(context, speak_function, listen_function):\n    para = context.get_parameter()\n    speak_function(para)\n</code></pre> <p>In this code snippet, the \"parameter_printer\" function is registered as a tributary using the <code>@register_tributary</code> decorator. The function takes three parameters: <code>context</code>, <code>speak_function</code>, and <code>listen_function</code>. The <code>context</code> parameter provides access to the conversation's context, allowing you to retrieve stored data. The <code>speak_function</code> parameter represents the function used to speak or output content to the user.</p> <p>In the \"parameter_printer\" function, the <code>context.get_parameter()</code> retrieves the stored message from the conversation's context. Then, the <code>speak_function(para)</code> outputs the retrieved message to the user.</p> <p>By creating this tributary and engaging it within the flow, you can seamlessly incorporate the custom functionality of the \"parameter_printer\" tributary into your conversational program.</p> <p>Tributaries in ChatFlow enable you to extend the capabilities of your chatbot or conversational agent by integrating custom logic and actions. They provide a flexible and modular approach to enhance the functionality and interactivity of your conversational programs.</p>"},{"location":"tutorials/#branch","title":"Branch","text":"<p>Branch control is a crucial aspect of building conversational programs in ChatFlow. It allows the program to make decisions and take different paths based on specific conditions. By using branching statements, you can create more interactive and dynamic chatbot experiences.</p> <p>To best fit the needs of a chatbot, ChatFlow provides several branching mechanisms. Let's explore some of them:</p>"},{"location":"tutorials/#matching-variable-content","title":"Matching Variable Content","text":"<p>The <code>match</code> statement is used to compare if a variable matches a specific regular expression pattern. It allows you to perform pattern matching and conditionally execute code based on the result.</p> <pre><code>flow origin {\n    listen for question for 5s\n    if timeout {\n        speak \"Timeout, conversation ended.\"\n    } else if question match \"(top up|recharge)\" {\n        engage charge_flow\n    } else {\n        speak \"Unrecognized request.\"\n        end\n    }\n}\n</code></pre> <p>In this example, the program listens for a <code>question</code> for a maximum of 5 seconds. If a timeout occurs, it speaks \"Timeout, conversation ended.\" If the <code>question</code> matches the regular expression pattern <code>(top up|recharge)</code>, it engages the <code>charge_flow</code> flow. Otherwise, it speaks \"Unrecognized request\" and ends the conversation.</p>"},{"location":"tutorials/#equality-comparison","title":"Equality Comparison","text":"<p>The <code>equals</code> statement is used to check if two values are equal. It is often used for comparing user input against expected values.</p> <pre><code>flow confirm {\n    speak \"Do you really want to charge \" + n + \" yuan? Please answer with 'yes' to proceed or 'no' to cancel.\"\n    assign false to confirmed\n    while not confirmed {\n        listen for confirmation\n        if confirmation equals \"yes\" {\n            handover charge_tributary\n            assign true to confirmed\n        } else if confirmation equals \"no\" {\n            speak \"Charge cancelled.\"\n            end\n        } else {\n            speak \"Please answer with 'yes' or 'no' only. Please repeat your choice.\"\n        }\n    }\n}\n</code></pre> <p>In this example, the program asks the user if they want to charge a specific amount. It listens for a <code>confirmation</code> and uses the <code>equals</code> statement to compare the input against \"yes\" and \"no\". If the confirmation is \"yes\", it hands over to the <code>charge_tributary</code> flow and sets <code>confirmed</code> to <code>true</code>. If the confirmation is \"no\", it speaks \"Charge cancelled\" and ends the conversation. If the confirmation is neither \"yes\" nor \"no\", it speaks a reminder message and continues listening for a valid response.</p>"},{"location":"tutorials/#timeout-handling","title":"Timeout Handling","text":"<p>ChatFlow provides a built-in variable called <code>timeout</code> that is automatically set after a <code>listen</code> statement. It allows you to handle timeouts and take appropriate actions when no input is received within a specified duration.</p> <pre><code>flow origin {\n    listen for question for 5s\n    if timeout {\n        speak \"Timeout, conversation ended.\"\n    } else {\n        // Handle user input\n    }\n}\n</code></pre> <p>In this example, the program listens for a <code>question</code> for a maximum of 5 seconds. If no input is received within the specified time, the <code>timeout</code> condition is triggered. Inside the <code>if timeout</code> block, the program speaks \"Timeout, conversation ended.\" You can use this mechanism to gracefully handle situations where the user takes too long to respond.</p> <p>By utilizing branching statements like <code>match</code>, <code>equals</code>, and <code>timeout</code>, you can create more sophisticated conversational flows in ChatFlow. These branching mechanisms enable your chatbot to make decisions based on user input and provide appropriate responses, enhancing the interactive and dynamic nature of the conversation.</p>"}]}