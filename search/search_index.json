{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ChatFlow","text":""},{"location":"#introduction","title":"Introduction","text":"<p>ChatFlow is a domain-specific language designed specifically for authoring conversational dialog flows, such as for chatbots and voice assistants. </p> <p>It provides an easy to read and write syntax that models natural conversations, with abstractions for common constructs needed for conversational interfaces. ChatFlow makes it simpler for non-programmers to define complex conversational experiences.</p> <p>The language can integrate tightly with Python enabling advanced functionality when required through custom code. ChatFlow aims to balance simplicity with versatility. </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Readability: ChatFlow syntax reads like natural language to enable non-programmers to understand and author dialog flows.</p> </li> <li> <p>Easy to use: The specialized DSL provides high-level abstractions tailored for conversations like dialog flows, conditional logic, variables, etc. making chatbot development intuitive.</p> </li> <li> <p>Integration: ChatFlow provides rich integration capabilities with external systems via Python. It allows data processing in real-time during the conversation. Users can define custom execution flows named \"tributary\", which enable integration with anything in Python including databases, APIs and more.</p> </li> <li> <p>Integration with python's async functionality: ChatFlow enables asynchronous, non-blocking execution of dialogs via Python's async/await model. This allows I/O operations like API calls to run in parallel without blocking during a conversation.  </p> </li> <li> <p>Interpreted: ChatFlow scripts are interpreted at runtime, enabling rapid prototyping. The interpreter provides early detection of errors in conversational logic during testing without needing compilation.</p> </li> <li> <p>Extensible: Users can extend ChatFlow functionality by calling out to Python code within dialog scripts. This allows adding advanced or custom processing logic when needed.</p> </li> </ul>"},{"location":"#learning-chatflow","title":"Learning ChatFlow","text":"<ol> <li>Quick Start</li> <li>Tutorial</li> <li>Grammar</li> </ol>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>ChatFlow owes much gratitude to the open source projects that helped make it possible.</p> <p>In particular:</p> <ul> <li>Lark     ChatFlow builds on the excellent Lark parsing toolkit for generating the abstract syntax tree from the Conversation Flow scripts. The ability to define a clean grammar and easily parse it into a manipulatable tree structure is invaluable.</li> </ul>"},{"location":"#license","title":"License","text":"<p>Lark uses the MIT license.</p>"},{"location":"BNF/","title":"BNF Definition of ChatFlow","text":"<p>Following is the BNF definition of ChatFlow:</p> <pre><code>&lt;chatflow&gt; ::= &lt;flow&gt;+\n\n&lt;flow&gt; ::= \"flow\" &lt;flow_name&gt; \"{\" &lt;block&gt; \"}\"\n\n&lt;block&gt; ::= &lt;statement&gt;*\n\n&lt;statement&gt; ::= &lt;if_statement&gt;\n              | &lt;speak_statement&gt;  \n              | &lt;engage_statement&gt;\n              | &lt;handover_statement&gt;\n              | &lt;end_statement&gt;\n              | &lt;listen_statement&gt;\n              | &lt;assign_statement&gt;\n              | &lt;while_statement&gt;  \n              | &lt;store_statement&gt;\n              | &lt;fetch_statement&gt;\n              | \"{\" &lt;block&gt; \"}\"\n\n&lt;store_statement&gt; ::= \"store\" &lt;value&gt;\n\n&lt;fetch_statement&gt; ::= \"fetch\" &lt;variable&gt;\n\n&lt;if_statement&gt; ::= \"if\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\" &lt;else_statement&gt;?\n\n&lt;else_statement&gt; ::= \"else\" \"{\" &lt;block&gt; \"}\"\n                  | \"else\" &lt;if_statement&gt;\n\n&lt;while_statement&gt; ::= \"while\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\"\n\n&lt;speak_statement&gt; ::= \"speak\" &lt;str_expression&gt;  \n\n&lt;str_expression&gt; ::= &lt;value&gt; (\"+\" &lt;value&gt;)*\n\n&lt;engage_statement&gt; ::= \"engage\" &lt;flow_name&gt;\n\n&lt;handover_statement&gt; ::= \"handover\" &lt;tributary_name&gt;  \n\n&lt;end_statement&gt; ::= \"end\"\n\n&lt;listen_statement&gt; ::= \"listen\" \"for\" &lt;variable&gt; (\"for\" &lt;time&gt;)?\n\n&lt;assign_statement&gt; ::= \"assign\" &lt;expression&gt; \"to\" &lt;variable&gt;\n\n&lt;condition&gt; ::= &lt;match_compare&gt; \n              | &lt;equal_compare&gt;\n              | &lt;larger_compare&gt; \n              | &lt;less_compare&gt;\n              | &lt;boolean&gt;\n              | &lt;timeout&gt;\n              | \"not\" &lt;condition&gt;\n\n&lt;larger_compare&gt; ::= &lt;expression&gt; \"larger\" \"than\" &lt;expression&gt;  \n\n&lt;less_compare&gt; ::= &lt;expression&gt; \"less\" \"than\" &lt;expression&gt;\n\n&lt;boolean&gt; ::= TRUE | FALSE\n\nTRUE ::= \"true\"  \n\nFALSE ::= \"false\"\n\n&lt;match_compare&gt; ::= &lt;expression&gt; \"match\" &lt;value&gt; (\"as\" &lt;variable&gt;)?\n\n&lt;equal_compare&gt; ::= &lt;expression&gt; \"equals\" &lt;expression&gt;\n\n&lt;expression&gt; ::= &lt;term&gt; (&lt;add_sub_operator&gt; &lt;term&gt;)*\n\n&lt;term&gt; ::= &lt;factor&gt; (&lt;mul_div_operator&gt; &lt;factor&gt;)*  \n\n&lt;factor&gt; ::= &lt;value&gt;\n           | \"(\" &lt;expression&gt; \")\"\n\n&lt;add_sub_operator&gt; ::= PLUS | MINUS\n\n&lt;mul_div_operator&gt; ::= TIMES | DIVIDE   \n\nTIMES ::= \"*\"  \n\nDIVIDE ::= \"/\"\n\nPLUS ::= \"+\"  \n\nMINUS ::= \"-\"\n\n&lt;value&gt; ::= &lt;timeout&gt;  \n          | &lt;literal&gt;\n          | &lt;variable&gt;   \n\n&lt;variable&gt; ::= &lt;identifier&gt;  \n\n&lt;identifier&gt; ::= IDENTIFIER\n\n&lt;flow_name&gt; ::= &lt;identifier&gt;\n\n&lt;tributary_name&gt; ::= &lt;identifier&gt; \n\n&lt;time&gt; ::= &lt;value&gt; &lt;time_unit&gt;  \n\n&lt;time_unit&gt; ::= SECOND | MINUTE | HOUR\n\nSECOND ::= \"s\"  \n\nMINUTE ::= \"m\"\n\nHOUR ::= \"h\"\n\n&lt;timeout&gt; ::= \"timeout\"\n\n&lt;literal&gt; ::= STRING  \n           | NUMBER\n\nIDENTIFIER ::= letter(letter | digit | \"_\")*\nletter ::= \"A\"..\"Z\" | \"a\"..\"z\"\ndigit ::= \"0\"..\"9\"  \n</code></pre>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright \u00a9 2023 65456u</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"async/","title":"Async Support","text":"<p>ChatFlow supports async mode in Python out of the box. To enable asynchronous execution of ChatFlow programs, you just need to use <code>Runtime.arun()</code> instead of <code>Runtime.run()</code>. </p> <p>For example, the following synchronous program:</p> <pre><code>def main():\n    interpreter = Interpreter(code=code)\n    runtime = Runtime(interpreter)\n    runtime.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>can be easily tranformed into asynchronous mode:</p> <pre><code>async def main():\n    interpreter = Interpreter(code=code) \n    runtime = Runtime(interpreter, async_flag=True)\n    await runtime.arun()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>You can also define your custom async speak and listen functions as well as async tributaries.</p> <p>In summary, ChatFlow enables:</p> <ul> <li>Async mode with simple Runtime swap</li> <li>Custom async speak, listen and tributaries</li> <li>Asynchronous, non-blocking execution</li> </ul>"},{"location":"context/","title":"Context","text":""},{"location":"context/#chatflow.context.Context","title":"<code>Context</code>","text":"<p>Context for a ChatFlow Flow</p> <p>This class represents the context for a ChatFlow flow. It stores information such as the flow's parameter, return value, scope, tree, and timeout status. It also provides methods for manipulating the scope and accessing variables within the scope.</p> Source code in <code>chatflow\\context.py</code> <pre><code>class Context:\n    \"\"\"Context for a ChatFlow Flow\n\n    This class represents the context for a ChatFlow flow. It stores information such as the flow's parameter,\n    return value, scope, tree, and timeout status. It also provides methods for manipulating the scope and accessing\n    variables within the scope.\n    \"\"\"\n\n    def __init__(self, parameter, tree):\n        \"\"\"\n        The constructor for the Context class.\n\n        Args:\n            parameter (any): The parameter used to passed to and from other flows.\n            tree (lark.Tree): The tree representing the ChatFlow Flow.\n        \"\"\"\n        self.parameter = parameter\n        self.return_value = None\n        self.scope = list()\n        self.scope_count = 0\n        self.tree = tree\n        self.timeout = False\n\n    def push_scope(self):\n        \"\"\"\n        Pushes a new scope onto the stack.\n\n        This method appends an empty dictionary to the `scope` list and increments the `scope_count` variable.\n\n        \"\"\"\n        self.scope.append(dict())\n        self.scope_count += 1\n\n    def pop_scope(self):\n        \"\"\"\n        Pops the topmost scope from the context.\n\n        This method removes the topmost scope from the context's scope stack.\n\n        \"\"\"\n        self.scope.pop()\n        self.scope_count -= 1\n\n    def get_variable(self, name):\n        \"\"\"Get the value of a variable from the current scope or any parent scopes.\n\n        Args:\n            name (str): The name of the variable.\n\n        Raises:\n            NameError: If the variable is not found in any scope.\n\n        Returns:\n            Any: The value of the variable.\n        \"\"\"\n        for i in range(self.scope_count - 1, -1, -1):\n            if name in self.scope[i]:\n                return self.scope[i][name]\n        raise NameError(f\"Name '{name}' is not defined\")\n\n    def set_variable(self, name, value):\n        \"\"\"Set the value of a variable in the context.\n\n        Args:\n            name (str): The name of the variable.\n            value (Any): The value to assign to the variable.\n\n        Returns:\n            bool: True if the variable was successfully set, False otherwise.\n        \"\"\"\n        for i in range(self.scope_count - 1, -1, -1):\n            if name in self.scope[i]:\n                self.scope[i][name] = value\n                return False\n        self.scope[self.scope_count - 1][name] = value\n        return True\n\n    def get_parameter(self):\n        \"\"\"Get the parameter value.\n\n        Returns:\n            The value of the parameter.\n        \"\"\"\n        return self.parameter\n\n    def set_timeout(self, timeout: bool):\n        \"\"\"Set the timeout value for the context.\n\n        Args:\n            timeout (bool): A boolean value indicating whether to enable or disable timeout.\n        \"\"\"\n        self.timeout = timeout\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object.\n\n        Returns:\n            str: A string representation of the object.\n        \"\"\"\n        return str(self.scope)\n\n    def set_parameter(self, parameter):\n        \"\"\"Set the value of the parameter.\n\n        Args:\n            parameter (type): The value to set for the parameter.\n        \"\"\"\n        self.parameter = parameter\n</code></pre>"},{"location":"context/#chatflow.context.Context.__init__","title":"<code>__init__(parameter, tree)</code>","text":"<p>The constructor for the Context class.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>any</code> <p>The parameter used to passed to and from other flows.</p> required <code>tree</code> <code>Tree</code> <p>The tree representing the ChatFlow Flow.</p> required Source code in <code>chatflow\\context.py</code> <pre><code>def __init__(self, parameter, tree):\n    \"\"\"\n    The constructor for the Context class.\n\n    Args:\n        parameter (any): The parameter used to passed to and from other flows.\n        tree (lark.Tree): The tree representing the ChatFlow Flow.\n    \"\"\"\n    self.parameter = parameter\n    self.return_value = None\n    self.scope = list()\n    self.scope_count = 0\n    self.tree = tree\n    self.timeout = False\n</code></pre>"},{"location":"context/#chatflow.context.Context.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the object.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a string representation of the object.\n\n    Returns:\n        str: A string representation of the object.\n    \"\"\"\n    return str(self.scope)\n</code></pre>"},{"location":"context/#chatflow.context.Context.get_parameter","title":"<code>get_parameter()</code>","text":"<p>Get the parameter value.</p> <p>Returns:</p> Type Description <p>The value of the parameter.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def get_parameter(self):\n    \"\"\"Get the parameter value.\n\n    Returns:\n        The value of the parameter.\n    \"\"\"\n    return self.parameter\n</code></pre>"},{"location":"context/#chatflow.context.Context.get_variable","title":"<code>get_variable(name)</code>","text":"<p>Get the value of a variable from the current scope or any parent scopes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable.</p> required <p>Raises:</p> Type Description <code>NameError</code> <p>If the variable is not found in any scope.</p> <p>Returns:</p> Name Type Description <code>Any</code> <p>The value of the variable.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def get_variable(self, name):\n    \"\"\"Get the value of a variable from the current scope or any parent scopes.\n\n    Args:\n        name (str): The name of the variable.\n\n    Raises:\n        NameError: If the variable is not found in any scope.\n\n    Returns:\n        Any: The value of the variable.\n    \"\"\"\n    for i in range(self.scope_count - 1, -1, -1):\n        if name in self.scope[i]:\n            return self.scope[i][name]\n    raise NameError(f\"Name '{name}' is not defined\")\n</code></pre>"},{"location":"context/#chatflow.context.Context.pop_scope","title":"<code>pop_scope()</code>","text":"<p>Pops the topmost scope from the context.</p> <p>This method removes the topmost scope from the context's scope stack.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def pop_scope(self):\n    \"\"\"\n    Pops the topmost scope from the context.\n\n    This method removes the topmost scope from the context's scope stack.\n\n    \"\"\"\n    self.scope.pop()\n    self.scope_count -= 1\n</code></pre>"},{"location":"context/#chatflow.context.Context.push_scope","title":"<code>push_scope()</code>","text":"<p>Pushes a new scope onto the stack.</p> <p>This method appends an empty dictionary to the <code>scope</code> list and increments the <code>scope_count</code> variable.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def push_scope(self):\n    \"\"\"\n    Pushes a new scope onto the stack.\n\n    This method appends an empty dictionary to the `scope` list and increments the `scope_count` variable.\n\n    \"\"\"\n    self.scope.append(dict())\n    self.scope_count += 1\n</code></pre>"},{"location":"context/#chatflow.context.Context.set_parameter","title":"<code>set_parameter(parameter)</code>","text":"<p>Set the value of the parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>type</code> <p>The value to set for the parameter.</p> required Source code in <code>chatflow\\context.py</code> <pre><code>def set_parameter(self, parameter):\n    \"\"\"Set the value of the parameter.\n\n    Args:\n        parameter (type): The value to set for the parameter.\n    \"\"\"\n    self.parameter = parameter\n</code></pre>"},{"location":"context/#chatflow.context.Context.set_timeout","title":"<code>set_timeout(timeout)</code>","text":"<p>Set the timeout value for the context.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>bool</code> <p>A boolean value indicating whether to enable or disable timeout.</p> required Source code in <code>chatflow\\context.py</code> <pre><code>def set_timeout(self, timeout: bool):\n    \"\"\"Set the timeout value for the context.\n\n    Args:\n        timeout (bool): A boolean value indicating whether to enable or disable timeout.\n    \"\"\"\n    self.timeout = timeout\n</code></pre>"},{"location":"context/#chatflow.context.Context.set_variable","title":"<code>set_variable(name, value)</code>","text":"<p>Set the value of a variable in the context.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable.</p> required <code>value</code> <code>Any</code> <p>The value to assign to the variable.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the variable was successfully set, False otherwise.</p> Source code in <code>chatflow\\context.py</code> <pre><code>def set_variable(self, name, value):\n    \"\"\"Set the value of a variable in the context.\n\n    Args:\n        name (str): The name of the variable.\n        value (Any): The value to assign to the variable.\n\n    Returns:\n        bool: True if the variable was successfully set, False otherwise.\n    \"\"\"\n    for i in range(self.scope_count - 1, -1, -1):\n        if name in self.scope[i]:\n            self.scope[i][name] = value\n            return False\n    self.scope[self.scope_count - 1][name] = value\n    return True\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Following are some example scripts of ChatFlow and their explanations:</p>"},{"location":"examples/#count-to-ten","title":"Count to Ten","text":"<pre><code>flow origin {\n    assign 0 to count\n    while count less than 10 {\n        assign count + 1 to count\n        speak count\n    }\n}\n</code></pre> <p>When the \"origin\" flow starts:</p> <ol> <li> <p>A variable <code>count</code> is initialized to 0</p> </li> <li> <p>A <code>while</code> loop begins which will iterate as long as <code>count</code> is less than 10</p> </li> <li> <p>In each iteration:</p> <p>a) <code>count</code> is incremented by 1 </p> <p>b) The current value of <code>count</code> is spoken out loud</p> <p>c) This continues till <code>count</code> reaches 10</p> </li> </ol> <p>So the core behavior would be:</p> <ul> <li>Initialize count variable </li> <li>Enter while loop</li> <li>Increment counter per iteration</li> <li>Speak updated count per loop</li> <li>Loop till termination condition is false</li> </ul> <p>So effectively, this would speak the numbers from 1 through 10 sequentially, demonstrating use of variables, conditional loops, variable assignments, and speak statements in ChatFlow.</p> <p>Let me know if you need any clarification or have additional questions on this example!</p>"},{"location":"examples/#guess-number-game","title":"Guess Number Game","text":"<pre><code>flow origin {\n    speak \"guess a number between 1 and 100\"\n    handover generate_random_number\n    fetch number\n    while true {\n        listen for answer\n        if answer matches \"\\d+\" as num {\n            store num\n            handover string_to_number\n            fetch num\n            if num larger than number {\n                speak \"too large\"\n            } else if num less than number {\n                speak \"too small\"\n            } else {\n                speak \"correct\"\n                end\n            }\n        } else {\n            speak \"not even wrong\"\n        }\n    }\n}\n</code></pre> <p>When this script is executed, the interpreter would behave as follows:</p> <ol> <li> <p>The \"origin\" flow begins execution. It first speaks prompting the user to guess a number.</p> </li> <li> <p>The \"generate_random_number\" tributary is handed over control to generate a random number between 1-100 and store it in the context.</p> </li> <li> <p>The number in the parameter of the Context is stored into number by <code>fetch number</code></p> </li> <li> <p>A while loop begins which iterates until the user guesses the correct number.</p> </li> <li> <p>In each iteration, the user's input is listened to, stored into parameter, processed by <code>string_to_number</code>  tributary, re-stored into num, and validated as a number.</p> </li> <li> <p>The input is converted to an integer and compared against the randomly generated number:</p> </li> </ol> <p>a. If too small/large, corresponding hints are provided.</p> <p>b. If correct, a success message is spoken and execution ends.</p> <ol> <li>If invalid input, an error message is spoken.</li> </ol>"},{"location":"examples/#recharge-service","title":"Recharge Service","text":"<pre><code>flow origin {\n    speak \"Welcome to the recharge system\"\n    listen for question for 10s\n    if timeout {\n        engage timeout_flow\n    }\n    if question matches \"recharge\" {\n        engage recharge_flow\n    } else if question matches \"query\" {\n        engage query_flow\n    } else {\n        engage unknown_flow\n    }\n}\n\nflow timeout_flow {\n    speak \"timeout, please try again\"\n    end\n}\n\nflow recharge_flow {\n    speak \"please input the amount you want to recharge\"\n    listen for question for 10s\n    if timeout {\n        engage timeout_flow\n    }\n    if question matches \"\\d+\" as amount {\n        store amount\n        handover recharge\n        end\n    }\n    engage unknown_flow\n}\n\nflow unknown_flow {\n    speak \"Sorry, I don't understand what you are saying\"\n    end\n}\n\nflow query_flow {\n    speak \"Querying your balance\"\n    handover query_balance\n    end\n}\n</code></pre> <p>When the \"origin\" flow starts, the user is welcomed and prompted to ask a question. The program listens for 10 seconds to get the user's input.</p> <p>There are several possible paths:</p> <ol> <li>If timeout occurs, the \"timeout_flow\" is engaged which speaks a timeout message and exits.</li> <li>If the input matches \"recharge\", the \"recharge_flow\" is initiated. It asks for recharge amount, listens for input, validates it as a number, stores it, and hands over to the \"recharge\" tributary to handle the actual recharge.</li> <li>If the input matches \"query\", the \"query_flow\" is started which directly hands over control to the \"query_balance\" tributary to query &amp; display account balance before exiting.</li> <li>For any other input, the \"unknown_flow\" is engaged, which speaks an error message before exiting.</li> </ol>"},{"location":"executors/","title":"Executors","text":"<p>Executors for running different types of statements.</p>"},{"location":"executors/#chatflow.executors.getters.compare.get_condition","title":"<code>get_condition(condition, context)</code>","text":"<p>Get the value of a condition based on its type.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>The condition node.</p> required <code>context</code> <code>Context</code> <p>The context dictionary.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>The value of the condition.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_condition(condition, context):\n    \"\"\"\n    Get the value of a condition based on its type.\n\n    Args:\n        condition (lark.Tree): The condition node.\n        context (Context): The context dictionary.\n\n    Returns:\n        result (bool): The value of the condition.\n\n    \"\"\"\n    condition = condition.children[0]\n    condition_type = condition.data\n    match condition_type:\n        case \"match_compare\":\n            return get_match_compare(condition, context)\n        case \"equal_compare\":\n            return get_equal_compare(condition, context)\n        case \"larger_compare\":\n            return get_larger_compare(condition, context)\n        case \"less_compare\":\n            return get_less_compare(condition, context)\n        case \"timeout\":\n            return context.timeout\n        case \"boolean\":\n            return get_boolean(condition)\n        case \"condition\":\n            return not get_condition(condition, context)\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_equal_compare","title":"<code>get_equal_compare(condition, context)</code>","text":"<p>Get the equal compare result.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>The condition to be compared.</p> required <code>context</code> <code>Context</code> <p>The context in which the comparison is performed.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the first value is equal to the second value, False otherwise.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_equal_compare(condition, context):\n    \"\"\"Get the equal compare result.\n\n    Args:\n        condition (lark.Tree): The condition to be compared.\n        context (Context): The context in which the comparison is performed.\n\n    Returns:\n        result (bool): True if the first value is equal to the second value, False otherwise.\n    \"\"\"\n    first_expression = condition.children[0]\n    second_expression = condition.children[1]\n    first_value = get_expression(first_expression, context)\n    second_value = get_expression(second_expression, context)\n    return first_value == second_value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_larger_compare","title":"<code>get_larger_compare(condition, context)</code>","text":"<p>Get the larger compare result.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>the condition object</p> required <code>context</code> <code>Context</code> <p>the context object</p> required <p>Returns:     bool: the result of the compare</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_larger_compare(condition, context):\n    \"\"\"Get the larger compare result.\n\n    Args:\n        condition (lark.Tree): the condition object\n        context (Context): the context object\n    Returns:\n        bool: the result of the compare\n    \"\"\"\n    first_expression = condition.children[0]\n    second_expression = condition.children[1]\n    first_value = get_expression(first_expression, context)\n    second_value = get_expression(second_expression, context)\n    return first_value &gt; second_value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_less_compare","title":"<code>get_less_compare(condition, context)</code>","text":"<p>Compare two values and return True if the first value is less than the second value.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Expression</code> <p>The condition to evaluate.</p> required <code>context</code> <code>Context</code> <p>The context in which the condition is evaluated.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the first value is less than the second value, False otherwise.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_less_compare(condition, context):\n    \"\"\"\n    Compare two values and return True if the first value is less than the second value.\n\n    Args:\n        condition (Expression): The condition to evaluate.\n        context (Context): The context in which the condition is evaluated.\n\n    Returns:\n        result (bool): True if the first value is less than the second value, False otherwise.\n    \"\"\"\n    first_expression = condition.children[0]\n    second_expression = condition.children[1]\n    first_value = get_expression(first_expression, context)\n    second_value = get_expression(second_expression, context)\n    return first_value &lt; second_value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.compare.get_match_compare","title":"<code>get_match_compare(condition, context)</code>","text":"<p>Get the match compare result.</p> <p>This function takes a condition and a context as input and performs a match compare operation. It checks if the expression matches the value using regular expressions.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Tree</code> <p>The condition object containing the expression, value, and optional variable.</p> required <code>context</code> <code>Context</code> <p>The context object containing the variables.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the expression or value is not a string.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the expression matches the value, False otherwise.</p> Source code in <code>chatflow\\executors\\getters\\compare.py</code> <pre><code>def get_match_compare(condition, context):\n    \"\"\"Get the match compare result.\n\n    This function takes a condition and a context as input and performs a match compare operation.\n    It checks if the expression matches the value using regular expressions.\n\n    Args:\n        condition (lark.Tree): The condition object containing the expression, value, and optional variable.\n        context (Context): The context object containing the variables.\n\n    Raises:\n        Exception: If the expression or value is not a string.\n\n    Returns:\n        result (bool): True if the expression matches the value, False otherwise.\n    \"\"\"\n    expression = condition.children[0]\n    expression = get_expression(expression, context)\n    value = condition.children[1]\n    value = get_value(value, context)\n    if type(expression) is not str or type(value) is not str:\n        raise Exception(\"Match compare only supports string values\")\n    if len(condition.children) == 2:\n        return re.match(value, expression)\n    else:\n        variable = condition.children[2]\n        variable = get_variable_name(variable)\n        result = re.search(value, expression)\n        if result:\n            context.set_variable(variable, result.group())\n            return True\n        else:\n            context.set_variable(variable, None)\n            return False\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_expression","title":"<code>get_expression(expression, context)</code>","text":"<p>Get the value of an expression. This function takes an expression and a context as input and returns the value of the expression. Args:     expression (lark.Tree): The expression to evaluate.     context (Context): The context in which the expression is evaluated. Returns:     Any: The value of the expression.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_expression(expression, context):\n    \"\"\"Get the value of an expression.\n    This function takes an expression and a context as input and returns the value of the expression.\n    Args:\n        expression (lark.Tree): The expression to evaluate.\n        context (Context): The context in which the expression is evaluated.\n    Returns:\n        Any: The value of the expression.\n    \"\"\"\n    term = expression.children[0]\n    value = get_term(term, context)\n    for i in range(1, len(expression.children), 2):\n        operator = expression.children[i].children[0]\n        term = expression.children[i + 1]\n        term_value = get_term(term, context)\n        if operator.type == \"PLUS\":\n            value += term_value\n        elif operator.type == \"MINUS\":\n            value -= term_value\n    return value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_factor","title":"<code>get_factor(factor, context)</code>","text":"<p>Get the value of a factor. This function takes a factor and a context as input and returns the value of the factor. Args:     factor (lark.Tree): The factor to evaluate.     context (Context): The context in which the factor is evaluated. Returns:     Any: The value of the factor.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_factor(factor, context):\n    \"\"\"Get the value of a factor.\n    This function takes a factor and a context as input and returns the value of the factor.\n    Args:\n        factor (lark.Tree): The factor to evaluate.\n        context (Context): The context in which the factor is evaluated.\n    Returns:\n        Any: The value of the factor.\n    \"\"\"\n    factor = factor.children[0]\n    if factor.data == \"value\":\n        result = get_value(factor, context)\n    else:\n        result = get_expression(factor, context)\n    return result\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_str_expression","title":"<code>get_str_expression(expression, context)</code>","text":"<p>Get the string representation of an expression.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Tree</code> <p>The expression to evaluate.</p> required <code>context</code> <code>Context</code> <p>The context in which the expression is evaluated.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>str</code> <p>The string representation of the evaluated expression.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_str_expression(expression, context):\n    \"\"\"Get the string representation of an expression.\n\n    Args:\n        expression (lark.Tree): The expression to evaluate.\n        context (Context): The context in which the expression is evaluated.\n\n    Returns:\n        result (str): The string representation of the evaluated expression.\n    \"\"\"\n    result = \"\"\n    for child in expression.children:\n        str_val = str(get_value(child, context))\n        result += str_val\n    return result\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.evaluate.get_term","title":"<code>get_term(term, context)</code>","text":"<p>Get the value of a term. This function takes a term and a context as input and returns the value of the term. Args:     term (lark.Tree): The term to evaluate.     context (Context): The context in which the term is evaluated. Returns:     Any: The value of the term.</p> Source code in <code>chatflow\\executors\\getters\\evaluate.py</code> <pre><code>def get_term(term, context):\n    \"\"\"Get the value of a term.\n    This function takes a term and a context as input and returns the value of the term.\n    Args:\n        term (lark.Tree): The term to evaluate.\n        context (Context): The context in which the term is evaluated.\n    Returns:\n        Any: The value of the term.\n    \"\"\"\n    factor = term.children[0]\n    value = get_factor(factor, context)\n    for i in range(1, len(term.children), 2):\n        operator = term.children[i].children[0]\n        factor = term.children[i + 1]\n        factor_value = get_factor(factor, context)\n        if operator.type == \"TIMES\":\n            value *= factor_value\n        elif operator.type == \"DIVIDE\":\n            value /= factor_value\n    return value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_boolean","title":"<code>get_boolean(condition)</code>","text":"<p>Get the boolean value from the parse tree. Args:     condition (lark.Tree): The parse tree node representing the boolean value. Returns:     bool: The boolean value. Raises:     Exception: If the boolean value is unknown.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_boolean(condition):\n    \"\"\"\n    Get the boolean value from the parse tree.\n    Args:\n        condition (lark.Tree): The parse tree node representing the boolean value.\n    Returns:\n        bool: The boolean value.\n    Raises:\n        Exception: If the boolean value is unknown.\n    \"\"\"\n    condition = condition.children[0]\n    if condition.type == \"TRUE\":\n        return True\n    elif condition.type == \"FALSE\":\n        return False\n    else:\n        raise Exception(\"Unknown boolean\")\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_flow_name","title":"<code>get_flow_name(tree)</code>","text":"<p>Get the flow name from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the flow name. Returns:     str: The flow name.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_flow_name(tree) -&gt; str:\n    \"\"\"\n    Get the flow name from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the flow name.\n    Returns:\n        str: The flow name.\n    \"\"\"\n    name = get_identifier(tree.children[0])\n    return name\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_identifier","title":"<code>get_identifier(tree)</code>","text":"<p>Get the identifier value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the identifier. Returns:     Any: The identifier value.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_identifier(tree):\n    \"\"\"\n    Get the identifier value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the identifier.\n    Returns:\n        Any: The identifier value.\n    \"\"\"\n    return tree.children[0].value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_literal","title":"<code>get_literal(tree)</code>","text":"<p>Get the literal value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the literal value. Returns:     Any: The literal value.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_literal(tree):\n    \"\"\"\n    Get the literal value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the literal value.\n    Returns:\n        Any: The literal value.\n    \"\"\"\n    value = tree.children[0]\n    match value.type:\n        case \"STRING_LITERAL\":\n            value = value.value[1:-1]\n        case \"NUMBER_LITERAL\":\n            value = int(value.value)\n    return value\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_time","title":"<code>get_time(tree, context)</code>","text":"<p>Get the time value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the time value.     context (Context): The context object containing variable values. Returns:     int: The time value in seconds.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_time(tree, context) -&gt; int:\n    \"\"\"\n    Get the time value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the time value.\n        context (Context): The context object containing variable values.\n    Returns:\n        int: The time value in seconds.\n    \"\"\"\n    timer = tree.children[0]\n    timer = get_value(timer, context)\n    unit = tree.children[1].children[0].data\n    match unit:\n        case \"second\":\n            timer *= 1\n        case \"minute\":\n            timer *= 60\n        case \"hour\":\n            timer *= 3600\n    return timer\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_tributary_name","title":"<code>get_tributary_name(tree)</code>","text":"<p>Get the tributary name from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the tributary name. Returns:     str: The tributary name.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_tributary_name(tree) -&gt; str:\n    \"\"\"\n    Get the tributary name from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the tributary name.\n    Returns:\n        str: The tributary name.\n    \"\"\"\n    name = get_identifier(tree.children[0])\n    return name\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_value","title":"<code>get_value(tree, context)</code>","text":"<p>Get the value from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the value.     context (Context): The context object containing variable values. Returns:     Any: The value.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_value(tree, context):\n    \"\"\"\n    Get the value from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the value.\n        context (Context): The context object containing variable values.\n    Returns:\n        Any: The value.\n    \"\"\"\n    value = tree.children[0]\n    match value.data:\n        case \"literal\":\n            return get_literal(value)\n        case \"variable\":\n            variable_name = get_variable_name(value)\n            return context.get_variable(variable_name)\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_variable","title":"<code>get_variable(value, context)</code>","text":"<p>Get the value of a variable from the context. Args:     value (lark.Tree): The parse tree node representing the variable.     context (Context): The context object containing variable values. Returns:     Any: The value of the variable.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_variable(value, context):\n    \"\"\"\n    Get the value of a variable from the context.\n    Args:\n        value (lark.Tree): The parse tree node representing the variable.\n        context (Context): The context object containing variable values.\n    Returns:\n        Any: The value of the variable.\n    \"\"\"\n    variable_name = value.children[0].value\n    return context.get_variable(variable_name)\n</code></pre>"},{"location":"executors/#chatflow.executors.getters.property.get_variable_name","title":"<code>get_variable_name(tree)</code>","text":"<p>Get the variable name from the parse tree. Args:     tree (lark.Tree): The parse tree node representing the variable. Returns:     (str): The variable name.</p> Source code in <code>chatflow\\executors\\getters\\property.py</code> <pre><code>def get_variable_name(tree) -&gt; str:\n    \"\"\"\n    Get the variable name from the parse tree.\n    Args:\n        tree (lark.Tree): The parse tree node representing the variable.\n    Returns:\n        (str): The variable name.\n    \"\"\"\n    return get_identifier(tree.children[0])\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.arun_handover","title":"<code>arun_handover(statement, context, speak_function, listen_function)</code>  <code>async</code>","text":"<p>Executes a handover to a specific tributary.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement object.</p> required <code>context</code> <code>Context</code> <p>The context object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking.</p> required <code>listen_function</code> <code>callable</code> <p>The function used for listening.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the specified tributary is not found.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>async def arun_handover(statement, context, speak_function, listen_function):\n    \"\"\"\n    Executes a handover to a specific tributary.\n\n    Args:\n        statement (lark.Tree): The statement object.\n        context (Context): The context object.\n        speak_function (callable): The function used for speaking.\n        listen_function (callable): The function used for listening.\n\n    Raises:\n        Exception: If the specified tributary is not found.\n    \"\"\"\n    tributary_name = get_tributary_name(statement.children[0])\n    tributary = get_tributary(tributary_name)\n    if tributary is None:\n        raise Exception(f\"Tributary {tributary_name} not found\")\n    await a_call_function(tributary, context, speak_function, listen_function)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.arun_listen","title":"<code>arun_listen(statement, context, listen_function)</code>  <code>async</code>","text":"<p>Executes the listen statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The listen statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required <code>listen_function</code> <code>callable</code> <p>The function to be called for listening.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value obtained from the listen function. None if timeout occurs.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>async def arun_listen(statement, context, listen_function):\n    \"\"\"Executes the listen statement.\n\n    Args:\n        statement (lark.Tree): The listen statement node.\n        context (Context): The execution context.\n        listen_function (callable): The function to be called for listening.\n\n    Returns:\n        (int): The value obtained from the listen function. None if timeout occurs.\n    \"\"\"\n    length = len(statement.children)\n    match length:\n        case 1:\n            value = await a_call_function(listen_function)\n            set_variable(statement.children[0], context, value)\n        case 2:\n            timer = get_time(statement.children[1], context)\n            value = await a_call_function(listen_function, timer)\n            if value is None:\n                context.set_timeout(True)\n            else:\n                set_variable(statement.children[0], context, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.arun_speak","title":"<code>arun_speak(statement, context, speak_function)</code>  <code>async</code>","text":"<p>Executes the speak function with the value obtained from the statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement from which to obtain the value.</p> required <code>context</code> <code>Context</code> <p>The context in which the statement is evaluated.</p> required <code>speak_function</code> <code>callable</code> <p>The function to be executed with the obtained value.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>async def arun_speak(statement, context, speak_function):\n    \"\"\"Executes the speak function with the value obtained from the statement.\n\n    Args:\n        statement (lark.Tree): The statement from which to obtain the value.\n        context (Context): The context in which the statement is evaluated.\n        speak_function (callable): The function to be executed with the obtained value.\n    \"\"\"\n    value = get_str_expression(statement.children[0], context)\n    await a_call_function(speak_function, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_assign","title":"<code>run_assign(statement, context)</code>","text":"<p>Assigns a value to a variable in the given context.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The assignment statement to be executed.</p> required <code>context</code> <code>Context</code> <p>The context in which the assignment is performed.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_assign(statement, context):\n    \"\"\"Assigns a value to a variable in the given context.\n\n    Args:\n        statement (lark.Tree): The assignment statement to be executed.\n        context (Context): The context in which the assignment is performed.\n    \"\"\"\n    expression = statement.children[0]\n    value = get_expression(expression, context)\n    variable = statement.children[1]\n    variable_name = get_variable_name(variable)\n    context.set_variable(variable_name, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_fetch","title":"<code>run_fetch(statement, context)</code>","text":"<p>Executes the fetch statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The fetch statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_fetch(statement, context):\n    \"\"\"Executes the fetch statement.\n\n    Args:\n        statement (lark.Tree): The fetch statement node.\n        context (Context): The execution context.\n    \"\"\"\n    value = context.get_parameter()\n    set_variable(statement.children[0], context, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_handover","title":"<code>run_handover(statement, context, speak_function, listen_function)</code>","text":"<p>Executes a handover to a specific tributary.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement object.</p> required <code>context</code> <code>Context</code> <p>The context object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking.</p> required <code>listen_function</code> <code>callable</code> <p>The function used for listening.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the specified tributary is not found.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_handover(statement, context, speak_function, listen_function):\n    \"\"\"\n    Executes a handover to a specific tributary.\n\n    Args:\n        statement (lark.Tree): The statement object.\n        context (Context): The context object.\n        speak_function (callable): The function used for speaking.\n        listen_function (callable): The function used for listening.\n\n    Raises:\n        Exception: If the specified tributary is not found.\n    \"\"\"\n    tributary_name = get_tributary_name(statement.children[0])\n    tributary = get_tributary(tributary_name)\n    if tributary is None:\n        raise Exception(f\"Tributary {tributary_name} not found\")\n    call_function(tributary, context, speak_function, listen_function)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_listen","title":"<code>run_listen(statement, context, listen_function)</code>","text":"<p>Executes the listen statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The listen statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required <code>listen_function</code> <code>callable</code> <p>The function to be called for listening.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value obtained from the listen function. None if timeout occurs.</p> Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_listen(statement, context, listen_function):\n    \"\"\"Executes the listen statement.\n\n    Args:\n        statement (lark.Tree): The listen statement node.\n        context (Context): The execution context.\n        listen_function (callable): The function to be called for listening.\n\n    Returns:\n        (int): The value obtained from the listen function. None if timeout occurs.\n    \"\"\"\n    length = len(statement.children)\n    match length:\n        case 1:\n            value = call_function(listen_function)\n            set_variable(statement.children[0], context, value)\n        case 2:\n            timer = get_time(statement.children[1], context)\n            value = call_function(listen_function, timer)\n            if value is None:\n                context.set_timeout(True)\n            else:\n                set_variable(statement.children[0], context, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_speak","title":"<code>run_speak(statement, context, speak_function)</code>","text":"<p>Executes the speak function with the value obtained from the statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement from which to obtain the value.</p> required <code>context</code> <code>Context</code> <p>The context in which the statement is evaluated.</p> required <code>speak_function</code> <code>callable</code> <p>The function to be executed with the obtained value.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_speak(statement, context, speak_function):\n    \"\"\"Executes the speak function with the value obtained from the statement.\n\n    Args:\n        statement (lark.Tree): The statement from which to obtain the value.\n        context (Context): The context in which the statement is evaluated.\n        speak_function (callable): The function to be executed with the obtained value.\n    \"\"\"\n    value = get_str_expression(statement.children[0], context)\n    call_function(speak_function, value)\n</code></pre>"},{"location":"executors/#chatflow.executors.runners.run_store","title":"<code>run_store(statement, context)</code>","text":"<p>Executes the store statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The store statement node.</p> required <code>context</code> <code>Context</code> <p>The execution context.</p> required Source code in <code>chatflow\\executors\\runners.py</code> <pre><code>def run_store(statement, context):\n    \"\"\"Executes the store statement.\n\n    Args:\n        statement (lark.Tree): The store statement node.\n        context (Context): The execution context.\n    \"\"\"\n    value = get_value(statement.children[0], context)\n    context.set_parameter(value)\n</code></pre>"},{"location":"executors/#chatflow.executors.setters.set_variable","title":"<code>set_variable(tree, context, value)</code>","text":"<p>Set the value of a variable in the context.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Tree</code> <p>The tree object.</p> required <code>context</code> <code>Context</code> <p>The context object.</p> required <code>value</code> <code>any</code> <p>The value to set.</p> required Source code in <code>chatflow\\executors\\setters.py</code> <pre><code>def set_variable(tree, context, value):\n    \"\"\"Set the value of a variable in the context.\n\n    Args:\n        tree (lark.Tree): The tree object.\n        context (Context): The context object.\n        value (any): The value to set.\n\n    \"\"\"\n    variable_name = get_variable_name(tree)\n    context.set_variable(variable_name, value)\n</code></pre>"},{"location":"grammar/","title":"Grammar","text":""},{"location":"grammar/#the-grammar-of-chatflow","title":"The Grammar of ChatFlow","text":"<p>ChatFlow features an easy to learn grammar to enable intuitive authoring of conversational dialog flows. This section covers the syntax, semantics and key components of the ChatFlow language.</p>"},{"location":"grammar/#table-of-contents","title":"Table of Contents","text":"<ul> <li>The Structure of a ChatFlow Program - Overview of flows, blocks and statements</li> <li>Lexical Definitions - Tokens, identifiers, keywords, comments and literals</li> <li>Statements - Details on each statement type and its syntax</li> <li>BNF Definition - Formal context-free grammar of ChatFlow using Backus\u2013Naur form</li> </ul>"},{"location":"interpreter/","title":"Interpreter","text":""},{"location":"interpreter/#chatflow.interpreter.Interpreter","title":"<code>Interpreter</code>","text":"<p>A class that represents an interpreter for executing ChatFlow scripts.</p> <p>Parameters:</p> Name Type Description Default <code>code_path</code> <code>str</code> <p>The path to the ChatFlow script file. Defaults to None.</p> <code>None</code> <code>code</code> <code>str</code> <p>The ChatFlow script code. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>script</code> <code>str</code> <p>The ChatFlow script code.</p> <code>parser</code> <code>Lark</code> <p>The Lark parser for parsing the ChatFlow script.</p> <code>tree</code> <code>Tree</code> <p>The parsed syntax tree of the ChatFlow script.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Returns a pretty-printed representation of the parsed syntax tree.</p> Source code in <code>chatflow\\interpreter.py</code> <pre><code>class Interpreter:\n    \"\"\"\n    A class that represents an interpreter for executing ChatFlow scripts.\n\n    Args:\n        code_path (str, optional): The path to the ChatFlow script file. Defaults to None.\n        code (str, optional): The ChatFlow script code. Defaults to None.\n\n    Attributes:\n        script (str): The ChatFlow script code.\n        parser (lark.Lark): The Lark parser for parsing the ChatFlow script.\n        tree (lark.Tree): The parsed syntax tree of the ChatFlow script.\n\n    Methods:\n        __repr__(str): Returns a pretty-printed representation of the parsed syntax tree.\n\n    \"\"\"\n\n    def __init__(\n                self,\n                code_path=None,\n                code=None,\n        ):\n        \"\"\"Initialize the Interpreter object.\n\n        Args:\n            code_path (str, optional): The path to the code file. Defaults to None.\n            code (str, optional): The code string. Defaults to None.\n        \"\"\"\n        if code_path:\n            with open(code_path, \"r\") as f:\n                self.script = f.read()\n        elif code:\n            self.script = code\n        self.parser = Lark(grammar, start=\"chatflow\", parser=\"lalr\")\n        self.tree = self.parser.parse(self.script)\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the object.\n\n        Returns:\n            str: A string representation of the object.\n        \"\"\"\n        return self.tree.pretty()\n</code></pre>"},{"location":"interpreter/#chatflow.interpreter.Interpreter.__init__","title":"<code>__init__(code_path=None, code=None)</code>","text":"<p>Initialize the Interpreter object.</p> <p>Parameters:</p> Name Type Description Default <code>code_path</code> <code>str</code> <p>The path to the code file. Defaults to None.</p> <code>None</code> <code>code</code> <code>str</code> <p>The code string. Defaults to None.</p> <code>None</code> Source code in <code>chatflow\\interpreter.py</code> <pre><code>def __init__(\n            self,\n            code_path=None,\n            code=None,\n    ):\n    \"\"\"Initialize the Interpreter object.\n\n    Args:\n        code_path (str, optional): The path to the code file. Defaults to None.\n        code (str, optional): The code string. Defaults to None.\n    \"\"\"\n    if code_path:\n        with open(code_path, \"r\") as f:\n            self.script = f.read()\n    elif code:\n        self.script = code\n    self.parser = Lark(grammar, start=\"chatflow\", parser=\"lalr\")\n    self.tree = self.parser.parse(self.script)\n</code></pre>"},{"location":"interpreter/#chatflow.interpreter.Interpreter.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the object.</p> Source code in <code>chatflow\\interpreter.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a string representation of the object.\n\n    Returns:\n        str: A string representation of the object.\n    \"\"\"\n    return self.tree.pretty()\n</code></pre>"},{"location":"lexical/","title":"Lexical Analysis","text":"<p>Lexical analysis is the first phase of the ChatFlow language processing. It involves breaking down the source code into tokens, which are the smallest meaningful units of the language. The lexer, also known as the tokenizer, scans the source code character by character and groups them into tokens based on predefined patterns and rules.</p>"},{"location":"lexical/#comment","title":"Comment","text":"<p>In ChatFlow, comments are denoted by a hash character (<code>#</code>) followed by the comment text. They can be used to provide explanations, document the code, or temporarily disable specific parts of the flow. Comments in ChatFlow are ignored by the language's interpreter and have no impact on the program's behavior or execution.</p> <p>For example:</p> <pre><code>flow origin {\n    # This is a comment explaining the purpose of this flow\n    speak \"Hello, world!\" # This line speaks a greeting message\n    # The following line is commented out to disable its execution\n    # listen for name\n}\n</code></pre> <p>In the above example, the comments provide additional information about the flow and the code. The interpreter ignores these comments, ensuring they don't affect the execution of the ChatFlow program.</p>"},{"location":"lexical/#identifiers-and-keywords","title":"Identifiers and Keywords","text":"<p>Identifiers are used to represent names in a programming language. In ChatFlow, an identifier is defined as a sequence of characters that follows a specific pattern.</p> <p>The pattern for identifiers in ChatFlow is defined using the following BNF notation:</p> <pre><code>IDENTIFIER ::= letter(letter | digit | \"_\")*\nletter ::= \"A\"..\"Z\" | \"a\"..\"z\"\ndigit ::= \"0\"..\"9\"  \n</code></pre> <p>An identifier must start with a letter (uppercase or lowercase) or an underscore, followed by zero or more letters, digits, or underscores. This means that identifiers can include a combination of letters (both uppercase and lowercase), digits, and underscores, but they cannot start with a digit.</p> <p>ChatFlow also has a set of reserved words or keywords that hold special meanings and cannot be used as regular identifiers. It is important to remember that these keywords must be spelled exactly as specified in the ChatFlow language and cannot be used as ordinary identifiers.</p> <p>Following are the keywords in ChatFlow:</p> <pre><code>flow        if          else        while       speak\nengage      handover    end         listen      for\nassign      to          true        false       match\nequals      larger      than        less        not\ntimeout     store       fetch\n</code></pre>"},{"location":"lexical/#literals","title":"Literals","text":"<p>In ChatFlow, literals are representations of constant values for certain built-in types.</p>"},{"location":"lexical/#string-literals","title":"String Literals","text":"<p>String literals in ChatFlow are represented by sequences of characters enclosed within double quotation marks (<code>\"</code>). They are used to denote textual data or strings.</p> <p>The BNF representation is as following:</p> <pre><code>STRING ::= '\"' (letter | digit |punctuation)* '\"'  \n</code></pre> <p>For example:</p> <pre><code>\"This is a string literal.\"\n\"Hello, world!\"\n\"12345\"\n\"Special characters: !@#$%^&amp;*()\"\n</code></pre> <p>String literals are commonly used for storing and manipulating textual data within ChatFlow scripts. They can be assigned to variables, passed as arguments to functions, concatenated, compared, and displayed as output during script execution.</p> <p>Make sure to enclose string literals within double quotation marks to indicate that they are strings.</p>"},{"location":"lexical/#number-literals","title":"Number Literals","text":"<p>Number literals in ChatFlow are used to represent numeric values, including integers and floating-point numbers.</p> <p>Here is the BNF representation of number literals in ChatFlow:</p> <pre><code>&lt;NUMBER_LITERAL&gt; ::= &lt;SIGNED_NUMBER&gt;\n\n&lt;SIGNED_NUMBER&gt; ::= [\"+\" | \"-\"] &lt;NUMBER&gt;\n\n&lt;NUMBER&gt; ::= &lt;FLOAT&gt; | &lt;INT&gt;  \n\n&lt;FLOAT&gt; ::= &lt;INT&gt; &lt;_EXP&gt; | &lt;DECIMAL&gt; &lt;_EXP&gt;?\n\n&lt;_EXP&gt; ::= (\"e\" | \"E\") &lt;SIGNED_INT&gt;\n\n&lt;SIGNED_FLOAT&gt; ::= [\"+\" | \"-\"] &lt;FLOAT&gt;  \n\n&lt;DECIMAL&gt; ::= &lt;INT&gt; \".\" &lt;INT&gt;? | \".\" &lt;INT&gt; \n\n&lt;SIGNED_INT&gt; ::= [\"+\" | \"-\"] &lt;INT&gt;\n\n&lt;INT&gt; ::= digit+\ndigit ::= \"0\"...\"9\"\n</code></pre> <p>These rules define the syntax for representing number literals in ChatFlow, allowing for the representation of both integers and floating-point numbers.</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#install-using-pypi","title":"Install using PyPI","text":"<p>You can install ChatFlow from PyPI using the following command:</p> <pre><code>pip install chatflow\n</code></pre>"},{"location":"quick-start/#install-from-source","title":"Install from source","text":"<p>Alternatively, you can install it from the source code. First, clone the repository:</p> <pre><code>git clone https://github.com/65456u/ChatFlow.git\ncd ChatFlow\n</code></pre> <p>Then, install the required packages:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Finally, install ChatFlow:</p> <pre><code>pip install .\n</code></pre>"},{"location":"quick-start/#initializing-the-interpreter","title":"Initializing the Interpreter","text":"<p>To run a ChatFlow program, you need to create an <code>Interpreter</code> object using the ChatFlow code you have written.</p> <p>You can directly create an <code>Interpreter</code> object and pass the code as a string, like this:</p> <pre><code>from chatflow import Interpreter\n\ncode = \"\"\"\nflow origin {\n  speak \"Hello, world!\" \n}\n\"\"\"\n\ninterpreter = Interpreter(code=code)\n</code></pre> <p>Alternatively, you can create an <code>Interpreter</code> object by specifying the path to a file containing your ChatFlow code:</p> <pre><code>interpreter = Interpreter(code_path=\"hello.flow\")\n</code></pre>"},{"location":"quick-start/#creating-a-runtime-instance","title":"Creating a Runtime Instance","text":"<p>The <code>Runtime</code> class is responsible for executing the ChatFlow program.</p> <p>You can create a <code>Runtime</code> instance by passing the <code>Interpreter</code> object along with your custom <code>speak</code> and <code>listen</code> functions. If you don't provide custom functions, the runtime will use the built-in default <code>speak</code> and <code>listen</code> methods.</p> <pre><code>from chatflow import Interpreter, Runtime\n\n\ndef my_speak_function(message):\n# Custom speak function implementation\n# ...\n\ndef my_listen_function(timer):\n# Custom listen function implementation\n# ...\n\n\nruntime = Runtime(interpreter, my_speak_function, my_listen_function)\n</code></pre> <p>By providing your own <code>speak</code> and <code>listen</code> functions, you can customize the behavior of the ChatFlow program according to your needs.</p>"},{"location":"quick-start/#running-the-program","title":"Running the Program","text":"<p>To execute the ChatFlow program, simply call the <code>run()</code> method on the <code>Runtime</code> instance:</p> <pre><code>runtime.run()\n</code></pre> <p>This will start the execution of the ChatFlow program, which will proceed according to the defined flows and interactions specified in the code.</p>"},{"location":"references/","title":"API References","text":"<p>API reference documentation covers the key classes and components of the ChatFlow runtime environment.</p>"},{"location":"references/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Interpreter - Parses ChatFlow code and builds an abstract syntax tree</li> <li>Runtime - Interprets and executes the ChatFlow program </li> <li>Context - Maintains state and data during execution</li> <li>Executors - Functions that execute individual ChatFlow statements</li> <li>Utils - Utility functions</li> <li>Test - Test tool for ChatFlow programs</li> </ul>"},{"location":"runtime/","title":"Runtime","text":""},{"location":"runtime/#chatflow.runtime.Runtime","title":"<code>Runtime</code>","text":"<p>The Runtime class represents the execution environment for the ChatFlow program.</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>Tree</code> <p>The abstract syntax tree of the ChatFlow program.</p> <code>flow_dict</code> <code>dict</code> <p>A dictionary mapping flow names to their corresponding blocks.</p> <code>exit</code> <code>bool</code> <p>A flag indicating whether the chat flow should exit.</p> <code>contextStack</code> <code>list</code> <p>A stack of context objects representing the execution context.</p> <code>speak_function</code> <code>callable</code> <p>The function used for speaking.</p> <code>listen_function</code> <code>callable</code> <p>The function used for listening.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the Runtime object.</p> <code>register_flow</code> <p>Registers the flows defined in the ChatFlow program.</p> <code>run</code> <p>Runs the chat flow.</p> <code>arun</code> <p>Runs the chat flow asynchronously.</p> <code>arun_flow</code> <p>Runs a specific flow in the ChatFlow program asynchronously.</p> <code>run_flow</code> <p>Runs a specific flow in the ChatFlow program.</p> <code>arun_block</code> <p>Runs a block of statements in the ChatFlow program asynchronously.</p> <code>run_block</code> <p>Runs a block of statements in the ChatFlow program.</p> <code>run_statement</code> <p>Runs a single statement in the ChatFlow program.</p> <code>arun_statement</code> <p>Runs a single statement in the ChatFlow program asynchronously.</p> <code>arun_if</code> <p>Runs an if statement in the ChatFlow program asynchronously.</p> <code>run_if</code> <p>Runs an if statement in the ChatFlow program.</p> <code>arun_else</code> <p>Runs an else statement in the ChatFlow program asynchronously.</p> <code>run_else</code> <p>Runs an else statement in the ChatFlow program.</p> <code>arun_engage</code> <p>Runs an engage statement in the ChatFlow program asynchronously.</p> <code>run_engage</code> <p>Runs an engage statement in the ChatFlow program.</p> <code>arun_while</code> <p>Runs a while statement in the ChatFlow program asynchronously.</p> <code>run_while</code> <p>Runs a while statement in the ChatFlow program.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>class Runtime:\n    \"\"\"\n    The Runtime class represents the execution environment for the ChatFlow program.\n\n    Attributes:\n        tree (lark.Tree): The abstract syntax tree of the ChatFlow program.\n        flow_dict (dict): A dictionary mapping flow names to their corresponding blocks.\n        exit (bool): A flag indicating whether the chat flow should exit.\n        contextStack (list): A stack of context objects representing the execution context.\n        speak_function (callable): The function used for speaking.\n        listen_function (callable): The function used for listening.\n\n    Methods:\n        __init__(self, interpreter, speak_function=None, listen_function=None): Initializes the Runtime object.\n        register_flow(self): Registers the flows defined in the ChatFlow program.\n        run(self): Runs the chat flow.\n        arun(self): Runs the chat flow asynchronously.\n        arun_flow(self, flow_name, parameter=None): Runs a specific flow in the ChatFlow program asynchronously.\n        run_flow(self, flow_name, parameter=None): Runs a specific flow in the ChatFlow program.\n        arun_block(self, block, context): Runs a block of statements in the ChatFlow program asynchronously.\n        run_block(self, block, context): Runs a block of statements in the ChatFlow program.\n        run_statement(self, statement, context): Runs a single statement in the ChatFlow program.\n        arun_statement(self, statement, context): Runs a single statement in the ChatFlow program asynchronously.\n        arun_if(self, statement, context): Runs an if statement in the ChatFlow program asynchronously.\n        run_if(self, statement, context): Runs an if statement in the ChatFlow program.\n        arun_else(self, statement, context): Runs an else statement in the ChatFlow program asynchronously.\n        run_else(self, statement, context): Runs an else statement in the ChatFlow program.\n        arun_engage(self, statement, context): Runs an engage statement in the ChatFlow program asynchronously.\n        run_engage(self, statement, context): Runs an engage statement in the ChatFlow program.\n        arun_while(self, statement, context): Runs a while statement in the ChatFlow program asynchronously.\n        run_while(self, statement, context): Runs a while statement in the ChatFlow program.\n    \"\"\"\n\n    def __init__(self, interpreter, speak_function=None, listen_function=None):\n        \"\"\"Initialize the Runtime object.\n\n        Args:\n            interpreter (Interpreter): The interpreter object.\n            speak_function (callable, optional): The function used for speaking. Defaults to print.\n            listen_function (callable, optional): The function used for listening. Defaults to read_input_with_timeout.\n\n        \"\"\"\n        self.tree = interpreter.tree\n        self.flow_dict = {}\n        self.exit = False\n        self.register_flow()\n        self.contextStack = []\n        self.speak_function = speak_function\n        self.listen_function = listen_function\n\n    def register_flow(self):\n        \"\"\"\n        Register the flows defined in the ChatFlow program.\n        \"\"\"\n        for flow in self.tree.children:\n            flow_name = flow.children[0].children[0].children[0]\n            block = flow.children[1]\n            self.flow_dict[flow_name] = block\n\n    def run(self):\n        \"\"\"\n        Runs the chat flow.\n\n        If the speak_function is not provided, it defaults to the print function.\n        If the listen_function is not provided, it defaults to the read_input_with_timeout function.\n\n        The chat flow starts from the \"origin\" flow.\n        \"\"\"\n        if self.speak_function is None:\n            self.speak_function = print\n        if self.listen_function is None:\n            self.listen_function = read_input_with_timeout\n        self.run_flow(\"origin\")\n\n    async def arun(self):\n        \"\"\"Runs the chatflow asynchronously.\n\n        This method is responsible for executing the chatflow asynchronously.\n        It sets the default speak and listen functions if not provided,\n        and then calls the `arun_flow` method to start the chatflow.\n\n        \"\"\"\n        if self.speak_function is None:\n            self.speak_function = aprint\n        if self.listen_function is None:\n            self.listen_function = a_read_input_with_timeout\n        await self.arun_flow(\"origin\")\n\n    async def arun_flow(self, flow_name, parameter=None):\n        \"\"\"\n        Run a specific flow in the ChatFlow program.\n\n        Args:\n            flow_name (str): The name of the flow to run.\n            parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n        \"\"\"\n        if flow_name not in self.flow_dict:\n            raise Exception(f\"Flow {flow_name} not found\")\n        tree = self.flow_dict[flow_name]\n        context = Context(parameter, tree)\n        self.contextStack.append(context)\n        await self.arun_block(tree, context)\n        self.contextStack.pop()\n\n    def run_flow(self, flow_name, parameter=None):\n        \"\"\"\n        Run a specific flow in the ChatFlow program.\n\n        Args:\n            flow_name (str): The name of the flow to run.\n            parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n        \"\"\"\n        if flow_name not in self.flow_dict:\n            raise Exception(f\"Flow {flow_name} not found\")\n        tree = self.flow_dict[flow_name]\n        context = Context(parameter, tree)\n        self.contextStack.append(context)\n        self.run_block(tree, context)\n        self.contextStack.pop()\n\n    async def arun_block(self, block, context):\n        \"\"\"\n        Run a block of statements in the ChatFlow program.\n\n        Args:\n            block (lark.Tree): The block of statements to run.\n            context (Context): The current context.\n        \"\"\"\n        context.push_scope()\n        for statement in block.children:\n            if self.exit:\n                return\n            await self.arun_statement(statement, context)\n\n    def run_block(self, block, context):\n        \"\"\"\n        Run a block of statements in the ChatFlow program.\n\n        Args:\n            block (lark.Tree): The block of statements to run.\n            context (Context): The current context.\n        \"\"\"\n        context.push_scope()\n        for statement in block.children:\n            if self.exit:\n                context.pop_scope()\n                return\n            self.run_statement(statement, context)\n        context.pop_scope()\n\n    def run_statement(self, statement, context):\n        \"\"\"\n        Run a single statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The statement to run.\n            context (Context): The current context.\n        \"\"\"\n        statement = statement.children[0]\n        state_type = statement.data\n        match state_type:\n            case \"speak_statement\":\n                run_speak(statement, context, self.speak_function)\n            case \"listen_statement\":\n                run_listen(statement, context, self.listen_function)\n            case \"if_statement\":\n                self.run_if(statement, context)\n            case \"engage_statement\":\n                self.run_engage(statement, context)\n            case \"assign_statement\":\n                run_assign(statement, context)\n            case \"end_statement\":\n                self.exit = True\n            case \"handover_statement\":\n                run_handover(\n                    statement, context, self.speak_function, self.listen_function\n                )\n            case \"while_statement\":\n                self.run_while(statement, context)\n            case \"store_statement\":\n                run_store(statement, context)\n            case \"fetch_statement\":\n                run_fetch(statement, context)\n            case \"block\":\n                self.run_block(statement, context)\n\n    async def arun_statement(self, statement, context):\n        \"\"\"\n        Run a single statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The statement to run.\n            context (Context): The current context.\n        \"\"\"\n        statement = statement.children[0]\n        state_type = statement.data\n        match state_type:\n            case \"speak_statement\":\n                await arun_speak(statement, context, self.speak_function)\n            case \"listen_statement\":\n                await arun_listen(statement, context, self.listen_function)\n            case \"if_statement\":\n                await self.arun_if(statement, context)\n            case \"engage_statement\":\n                await self.arun_engage(statement, context)\n            case \"assign_statement\":\n                run_assign(statement, context)\n            case \"end_statement\":\n                self.exit = True\n            case \"handover_statement\":\n                await arun_handover(\n                    statement, context, self.speak_function, self.listen_function\n                )\n            case \"while_statement\":\n                await self.arun_while(statement, context)\n            case \"store_statement\":\n                run_store(statement, context)\n            case \"fetch_statement\":\n                run_fetch(statement, context)\n            case \"block\":\n                await self.arun_block(statement, context)\n\n    async def arun_if(self, statement, context):\n        \"\"\"\n        Run an if statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The if statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        result = get_condition(condition, context)\n        if result:\n            await self.arun_block(statement.children[1], context)\n        else:\n            if len(statement.children) == 3:\n                await self.arun_else(statement.children[2], context)\n\n    def run_if(self, statement, context):\n        \"\"\"\n        Run an if statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The if statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        result = get_condition(condition, context)\n        if result:\n            self.run_block(statement.children[1], context)\n        else:\n            if len(statement.children) == 3:\n                self.run_else(statement.children[2], context)\n\n    async def arun_else(self, statement, context):\n        \"\"\"\n        Run an else statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The else statement to run.\n            context (Context): The current context.\n        \"\"\"\n        else_statement = statement.children[0]\n        match else_statement.data:\n            case \"block\":\n                await self.arun_block(else_statement, context)\n            case \"if_statement\":\n                await self.arun_if(else_statement, context)\n\n    def run_else(self, statement, context):\n        \"\"\"\n        Run an else statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The else statement to run.\n            context (Context): The current context.\n        \"\"\"\n        else_statement = statement.children[0]\n        match else_statement.data:\n            case \"block\":\n                self.run_block(else_statement, context)\n            case \"if_statement\":\n                self.run_if(else_statement, context)\n\n    async def arun_engage(self, statement, context):\n        \"\"\"\n        Run an engage statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The engage statement to run.\n            context (Context): The current context.\n        \"\"\"\n        flow_name = get_flow_name(statement.children[0])\n        await self.arun_flow(flow_name, context.get_parameter())\n\n    def run_engage(self, statement, context):\n        \"\"\"\n        Run an engage statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The engage statement to run.\n            context (Context): The current context.\n        \"\"\"\n        flow_name = get_flow_name(statement.children[0])\n        self.run_flow(flow_name, context.get_parameter())\n\n    async def arun_while(self, statement, context):\n        \"\"\"\n        Run a while statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The while statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        while get_condition(condition, context):\n            if self.exit:\n                return\n            await self.arun_block(statement.children[1], context)\n\n    def run_while(self, statement, context):\n        \"\"\"\n        Run a while statement in the ChatFlow program.\n\n        Args:\n            statement (lark.Tree): The while statement to run.\n            context (Context): The current context.\n        \"\"\"\n        condition = statement.children[0]\n        while get_condition(condition, context):\n            if self.exit:\n                return\n            self.run_block(statement.children[1], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.__init__","title":"<code>__init__(interpreter, speak_function=None, listen_function=None)</code>","text":"<p>Initialize the Runtime object.</p> <p>Parameters:</p> Name Type Description Default <code>interpreter</code> <code>Interpreter</code> <p>The interpreter object.</p> required <code>speak_function</code> <code>callable</code> <p>The function used for speaking. Defaults to print.</p> <code>None</code> <code>listen_function</code> <code>callable</code> <p>The function used for listening. Defaults to read_input_with_timeout.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>def __init__(self, interpreter, speak_function=None, listen_function=None):\n    \"\"\"Initialize the Runtime object.\n\n    Args:\n        interpreter (Interpreter): The interpreter object.\n        speak_function (callable, optional): The function used for speaking. Defaults to print.\n        listen_function (callable, optional): The function used for listening. Defaults to read_input_with_timeout.\n\n    \"\"\"\n    self.tree = interpreter.tree\n    self.flow_dict = {}\n    self.exit = False\n    self.register_flow()\n    self.contextStack = []\n    self.speak_function = speak_function\n    self.listen_function = listen_function\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun","title":"<code>arun()</code>  <code>async</code>","text":"<p>Runs the chatflow asynchronously.</p> <p>This method is responsible for executing the chatflow asynchronously. It sets the default speak and listen functions if not provided, and then calls the <code>arun_flow</code> method to start the chatflow.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun(self):\n    \"\"\"Runs the chatflow asynchronously.\n\n    This method is responsible for executing the chatflow asynchronously.\n    It sets the default speak and listen functions if not provided,\n    and then calls the `arun_flow` method to start the chatflow.\n\n    \"\"\"\n    if self.speak_function is None:\n        self.speak_function = aprint\n    if self.listen_function is None:\n        self.listen_function = a_read_input_with_timeout\n    await self.arun_flow(\"origin\")\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_block","title":"<code>arun_block(block, context)</code>  <code>async</code>","text":"<p>Run a block of statements in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Tree</code> <p>The block of statements to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_block(self, block, context):\n    \"\"\"\n    Run a block of statements in the ChatFlow program.\n\n    Args:\n        block (lark.Tree): The block of statements to run.\n        context (Context): The current context.\n    \"\"\"\n    context.push_scope()\n    for statement in block.children:\n        if self.exit:\n            return\n        await self.arun_statement(statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_else","title":"<code>arun_else(statement, context)</code>  <code>async</code>","text":"<p>Run an else statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The else statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_else(self, statement, context):\n    \"\"\"\n    Run an else statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The else statement to run.\n        context (Context): The current context.\n    \"\"\"\n    else_statement = statement.children[0]\n    match else_statement.data:\n        case \"block\":\n            await self.arun_block(else_statement, context)\n        case \"if_statement\":\n            await self.arun_if(else_statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_engage","title":"<code>arun_engage(statement, context)</code>  <code>async</code>","text":"<p>Run an engage statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The engage statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_engage(self, statement, context):\n    \"\"\"\n    Run an engage statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The engage statement to run.\n        context (Context): The current context.\n    \"\"\"\n    flow_name = get_flow_name(statement.children[0])\n    await self.arun_flow(flow_name, context.get_parameter())\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_flow","title":"<code>arun_flow(flow_name, parameter=None)</code>  <code>async</code>","text":"<p>Run a specific flow in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>flow_name</code> <code>str</code> <p>The name of the flow to run.</p> required <code>parameter</code> <code>any</code> <p>The parameter to pass to the flow. Defaults to None.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_flow(self, flow_name, parameter=None):\n    \"\"\"\n    Run a specific flow in the ChatFlow program.\n\n    Args:\n        flow_name (str): The name of the flow to run.\n        parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n    \"\"\"\n    if flow_name not in self.flow_dict:\n        raise Exception(f\"Flow {flow_name} not found\")\n    tree = self.flow_dict[flow_name]\n    context = Context(parameter, tree)\n    self.contextStack.append(context)\n    await self.arun_block(tree, context)\n    self.contextStack.pop()\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_if","title":"<code>arun_if(statement, context)</code>  <code>async</code>","text":"<p>Run an if statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The if statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_if(self, statement, context):\n    \"\"\"\n    Run an if statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The if statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    result = get_condition(condition, context)\n    if result:\n        await self.arun_block(statement.children[1], context)\n    else:\n        if len(statement.children) == 3:\n            await self.arun_else(statement.children[2], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_statement","title":"<code>arun_statement(statement, context)</code>  <code>async</code>","text":"<p>Run a single statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_statement(self, statement, context):\n    \"\"\"\n    Run a single statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The statement to run.\n        context (Context): The current context.\n    \"\"\"\n    statement = statement.children[0]\n    state_type = statement.data\n    match state_type:\n        case \"speak_statement\":\n            await arun_speak(statement, context, self.speak_function)\n        case \"listen_statement\":\n            await arun_listen(statement, context, self.listen_function)\n        case \"if_statement\":\n            await self.arun_if(statement, context)\n        case \"engage_statement\":\n            await self.arun_engage(statement, context)\n        case \"assign_statement\":\n            run_assign(statement, context)\n        case \"end_statement\":\n            self.exit = True\n        case \"handover_statement\":\n            await arun_handover(\n                statement, context, self.speak_function, self.listen_function\n            )\n        case \"while_statement\":\n            await self.arun_while(statement, context)\n        case \"store_statement\":\n            run_store(statement, context)\n        case \"fetch_statement\":\n            run_fetch(statement, context)\n        case \"block\":\n            await self.arun_block(statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.arun_while","title":"<code>arun_while(statement, context)</code>  <code>async</code>","text":"<p>Run a while statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The while statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>async def arun_while(self, statement, context):\n    \"\"\"\n    Run a while statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The while statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    while get_condition(condition, context):\n        if self.exit:\n            return\n        await self.arun_block(statement.children[1], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.register_flow","title":"<code>register_flow()</code>","text":"<p>Register the flows defined in the ChatFlow program.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>def register_flow(self):\n    \"\"\"\n    Register the flows defined in the ChatFlow program.\n    \"\"\"\n    for flow in self.tree.children:\n        flow_name = flow.children[0].children[0].children[0]\n        block = flow.children[1]\n        self.flow_dict[flow_name] = block\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run","title":"<code>run()</code>","text":"<p>Runs the chat flow.</p> <p>If the speak_function is not provided, it defaults to the print function. If the listen_function is not provided, it defaults to the read_input_with_timeout function.</p> <p>The chat flow starts from the \"origin\" flow.</p> Source code in <code>chatflow\\runtime.py</code> <pre><code>def run(self):\n    \"\"\"\n    Runs the chat flow.\n\n    If the speak_function is not provided, it defaults to the print function.\n    If the listen_function is not provided, it defaults to the read_input_with_timeout function.\n\n    The chat flow starts from the \"origin\" flow.\n    \"\"\"\n    if self.speak_function is None:\n        self.speak_function = print\n    if self.listen_function is None:\n        self.listen_function = read_input_with_timeout\n    self.run_flow(\"origin\")\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_block","title":"<code>run_block(block, context)</code>","text":"<p>Run a block of statements in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Tree</code> <p>The block of statements to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_block(self, block, context):\n    \"\"\"\n    Run a block of statements in the ChatFlow program.\n\n    Args:\n        block (lark.Tree): The block of statements to run.\n        context (Context): The current context.\n    \"\"\"\n    context.push_scope()\n    for statement in block.children:\n        if self.exit:\n            context.pop_scope()\n            return\n        self.run_statement(statement, context)\n    context.pop_scope()\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_else","title":"<code>run_else(statement, context)</code>","text":"<p>Run an else statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The else statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_else(self, statement, context):\n    \"\"\"\n    Run an else statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The else statement to run.\n        context (Context): The current context.\n    \"\"\"\n    else_statement = statement.children[0]\n    match else_statement.data:\n        case \"block\":\n            self.run_block(else_statement, context)\n        case \"if_statement\":\n            self.run_if(else_statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_engage","title":"<code>run_engage(statement, context)</code>","text":"<p>Run an engage statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The engage statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_engage(self, statement, context):\n    \"\"\"\n    Run an engage statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The engage statement to run.\n        context (Context): The current context.\n    \"\"\"\n    flow_name = get_flow_name(statement.children[0])\n    self.run_flow(flow_name, context.get_parameter())\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_flow","title":"<code>run_flow(flow_name, parameter=None)</code>","text":"<p>Run a specific flow in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>flow_name</code> <code>str</code> <p>The name of the flow to run.</p> required <code>parameter</code> <code>any</code> <p>The parameter to pass to the flow. Defaults to None.</p> <code>None</code> Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_flow(self, flow_name, parameter=None):\n    \"\"\"\n    Run a specific flow in the ChatFlow program.\n\n    Args:\n        flow_name (str): The name of the flow to run.\n        parameter (any, optional): The parameter to pass to the flow. Defaults to None.\n    \"\"\"\n    if flow_name not in self.flow_dict:\n        raise Exception(f\"Flow {flow_name} not found\")\n    tree = self.flow_dict[flow_name]\n    context = Context(parameter, tree)\n    self.contextStack.append(context)\n    self.run_block(tree, context)\n    self.contextStack.pop()\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_if","title":"<code>run_if(statement, context)</code>","text":"<p>Run an if statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The if statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_if(self, statement, context):\n    \"\"\"\n    Run an if statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The if statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    result = get_condition(condition, context)\n    if result:\n        self.run_block(statement.children[1], context)\n    else:\n        if len(statement.children) == 3:\n            self.run_else(statement.children[2], context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_statement","title":"<code>run_statement(statement, context)</code>","text":"<p>Run a single statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_statement(self, statement, context):\n    \"\"\"\n    Run a single statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The statement to run.\n        context (Context): The current context.\n    \"\"\"\n    statement = statement.children[0]\n    state_type = statement.data\n    match state_type:\n        case \"speak_statement\":\n            run_speak(statement, context, self.speak_function)\n        case \"listen_statement\":\n            run_listen(statement, context, self.listen_function)\n        case \"if_statement\":\n            self.run_if(statement, context)\n        case \"engage_statement\":\n            self.run_engage(statement, context)\n        case \"assign_statement\":\n            run_assign(statement, context)\n        case \"end_statement\":\n            self.exit = True\n        case \"handover_statement\":\n            run_handover(\n                statement, context, self.speak_function, self.listen_function\n            )\n        case \"while_statement\":\n            self.run_while(statement, context)\n        case \"store_statement\":\n            run_store(statement, context)\n        case \"fetch_statement\":\n            run_fetch(statement, context)\n        case \"block\":\n            self.run_block(statement, context)\n</code></pre>"},{"location":"runtime/#chatflow.runtime.Runtime.run_while","title":"<code>run_while(statement, context)</code>","text":"<p>Run a while statement in the ChatFlow program.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Tree</code> <p>The while statement to run.</p> required <code>context</code> <code>Context</code> <p>The current context.</p> required Source code in <code>chatflow\\runtime.py</code> <pre><code>def run_while(self, statement, context):\n    \"\"\"\n    Run a while statement in the ChatFlow program.\n\n    Args:\n        statement (lark.Tree): The while statement to run.\n        context (Context): The current context.\n    \"\"\"\n    condition = statement.children[0]\n    while get_condition(condition, context):\n        if self.exit:\n            return\n        self.run_block(statement.children[1], context)\n</code></pre>"},{"location":"statement/","title":"Statements","text":""},{"location":"statement/#statements","title":"Statements","text":"<p>The ChatFlow statement consists of various types of statements that control the conversation flow and interact with the user.</p>"},{"location":"statement/#if-statement","title":"If Statement","text":"<p>The if statement in ChatFlow allows you to introduce conditional branching within your conversation flow. It enables you to make decisions based on specific conditions and execute different sets of statements accordingly.</p> <p>The syntax for the if statement in ChatFlow is as follows:</p> <pre><code>&lt;if_statement&gt; ::= \"if\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\" &lt;else_statement&gt;?\n\n&lt;else_statement&gt; ::= \"else\" \"{\" &lt;block&gt; \"}\"\n                  | \"else\" &lt;if_statement&gt;\n</code></pre> <p>In this syntax, the \"condition\" represents an expression that evaluates to a Boolean value. If the condition is true, the statements within the first block are executed. Optionally, an \"else\" block can be included, which contains statements that are executed when the condition is false. The \"else\" block can either be a block of statements or another if statement, allowing for nested conditional logic.</p>"},{"location":"statement/#speak-statement","title":"Speak Statement","text":"<p>The speak statement is used to send a message or response to the user during the conversation. It allows you to provide information, ask questions, or guide the user through the interaction.</p> <p>The syntax for the speak statement in ChatFlow is as follows:</p> <pre><code>&lt;speak_statement&gt; ::= \"speak\" &lt;str_expression&gt;  \n\n&lt;str_expression&gt; ::= &lt;value&gt; (\"+\" &lt;value&gt;)*\n</code></pre> <p>In this syntax, the \"str_expression\" represents the content of the message to be spoken. It can be a concatenation of multiple values using the \"+\" operator. The values can be string literals, variable names, or expressions that evaluate to a string.</p>"},{"location":"statement/#engage-statement","title":"Engage Statement","text":"<p>The engage statement in ChatFlow allows you to transition from the current flow to another flow. It enables you to modularize your conversation and organize it into separate flows.</p> <p>The syntax for the engage statement in ChatFlow is as follows:</p> <pre><code>&lt;engage_statement&gt; ::= \"engage\" &lt;flow_name&gt;\n</code></pre> <p>In this syntax, the \"flow_name\" represents the name of the flow that you want to engage with. It allows you to initiate another flow within the current flow, continuing the conversation in a different context.</p>"},{"location":"statement/#handover-statement","title":"Handover Statement","text":"<p>The handover statement in ChatFlow is used to transfer the conversation to another tributary, which is an user-defined external program. It allows you to hand over the conversation to a different system or service for further processing.</p> <pre><code>&lt;handover_statement&gt; ::= \"handover\" &lt;tributary_name&gt;\n</code></pre>"},{"location":"statement/#end-statement","title":"End Statement","text":"<p>The end statement in ChatFlow is used to stop the execution of the entire program. It terminates the conversation and exits the ChatFlow program.</p> <pre><code>end_statement    ::= \"end\"\n</code></pre>"},{"location":"statement/#listen-statement","title":"Listen Statement","text":"<p>The listen statement in ChatFlow is used to listen for user input during the conversation. It allows the ChatFlow program to wait for the user to provide a response before continuing with the execution. If timeout is reached, the timeout variable in the context if automatically set.</p> <pre><code>&lt;listen_statement&gt; ::= \"listen\" \"for\" &lt;variable&gt; (\"for\" &lt;time&gt;)?\n</code></pre>"},{"location":"statement/#assign-statement","title":"Assign Statement","text":"<p>The assign statement in ChatFlow is used to assign a value to a variable. It allows you to store and manipulate data within the ChatFlow program.</p> <pre><code>&lt;assign_statement&gt; ::= \"assign\" &lt;expression&gt; \"to\" &lt;variable&gt;\n</code></pre>"},{"location":"statement/#while-statement","title":"While Statement","text":"<p>The while statement in ChatFlow allows you to create a loop that executes a block of statements repeatedly as long as a specific condition is true.</p> <pre><code>&lt;while_statement&gt; ::= \"while\" &lt;condition&gt; \"{\" &lt;block&gt; \"}\"\n</code></pre>"},{"location":"statement/#store-statement","title":"Store Statement","text":"<p>The store statement in ChatFlow is used to store a value in the parameter within the context, enabling the passing of information from one flow to another flow or a tributary. It allows you to store data that can be accessed and utilized across different parts of the conversation.</p> <pre><code>&lt;store_statement&gt; ::= \"store\" &lt;value&gt;\n</code></pre> <p>In this syntax, the \"value\" represents the data or value that you want to store in the parameter within the context. By utilizing the store statement, you can preserve and retrieve information as needed throughout the conversation. This feature facilitates seamless information sharing and enhances the flexibility and functionality of your ChatFlow program.</p>"},{"location":"statement/#fetch-statement","title":"Fetch Statement","text":"<p>The fetch statement in ChatFlow is used to retrieve the stored value from the parameter within the context. It allows you to access data that has been previously stored using the store statement.</p> <pre><code>&lt;fetch_statement&gt; ::= \"fetch\" &lt;variable&gt;\n</code></pre> <p>In this syntax, the \"value\" represents the data or value that you want to retrieve from the parameter within the context. By utilizing the fetch statement, you can access stored information and use it in your conversation flow. This enables you to leverage previously stored data and incorporate it into your ChatFlow program in a dynamic and customized manner.</p>"},{"location":"test/","title":"Test","text":""},{"location":"test/#chatflow.test.create_stubbed_functions","title":"<code>create_stubbed_functions(input_list, output_list)</code>","text":"<p>Creates a stub for the speak and listen functions.</p> <p>Parameters:</p> Name Type Description Default <code>input_list</code> <code>list</code> <p>A list of strings to be returned by the listen function.</p> required <code>output_list</code> <code>list</code> <p>A list of strings to be compared with the spoken list.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the stubbed speak and listen functions.</p> Source code in <code>chatflow\\test.py</code> <pre><code>def create_stubbed_functions(input_list: list, output_list: list):\n    \"\"\"Creates a stub for the speak and listen functions.\n\n    Args:\n        input_list (list): A list of strings to be returned by the listen function.\n        output_list (list): A list of strings to be compared with the spoken list.\n\n    Returns:\n        (tuple): A tuple containing the stubbed speak and listen functions.\n    \"\"\"\n    spoken = []\n\n    def speak_function(message):\n        nonlocal spoken\n        spoken.append(message)\n\n    def listen_function(timeout=None):\n        nonlocal input_list\n        if len(input_list) == 0:\n            return None\n        else:\n            return input_list.pop(0)\n\n    def judge():\n        nonlocal spoken\n        nonlocal output_list\n        return spoken == output_list\n\n    return speak_function, listen_function, judge\n</code></pre>"},{"location":"test/#chatflow.test.run_stubbed_code","title":"<code>run_stubbed_code(input_list, output_list, code_path)</code>","text":"<p>Runs the code with stubbed speak and listen functions.</p> <p>Parameters:</p> Name Type Description Default <code>input_list</code> <code>list</code> <p>A list of strings to be returned by the listen function.</p> required <code>output_list</code> <code>list</code> <p>A list of strings to be compared with the spoken list.</p> required <code>code_path</code> <code>str</code> <p>The path to the code file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the spoken list matches the output list, False otherwise.</p> Source code in <code>chatflow\\test.py</code> <pre><code>def run_stubbed_code(input_list: list, output_list: list, code_path: str):\n    \"\"\"Runs the code with stubbed speak and listen functions.\n\n    Args:\n        input_list (list): A list of strings to be returned by the listen function.\n        output_list (list): A list of strings to be compared with the spoken list.\n        code_path (str): The path to the code file.\n\n    Returns:\n        (bool): True if the spoken list matches the output list, False otherwise.\n    \"\"\"\n    speak, listen, judge = create_stubbed_functions(input_list, output_list)\n    interpreter = Interpreter(code_path=code_path)\n    runtime = Runtime(interpreter, speak, listen)\n    runtime.run()\n    return judge()\n</code></pre>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#chatflow.utils.a_call_function","title":"<code>a_call_function(func, *args, **kwargs)</code>  <code>async</code>","text":"<p>Calls a function, either synchronously or asynchronously, depending on the type of the function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to be called.</p> required <code>*args</code> <p>Positional arguments to be passed to the function.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to be passed to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the function call.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>async def a_call_function(func, *args, **kwargs):\n    \"\"\"\n    Calls a function, either synchronously or asynchronously, depending on the type of the function.\n\n    Args:\n        func (callable): The function to be called.\n        *args: Positional arguments to be passed to the function.\n        **kwargs: Keyword arguments to be passed to the function.\n\n    Returns:\n        The result of the function call.\n    \"\"\"\n    if inspect.iscoroutinefunction(func):\n        result = await func(*args, **kwargs)\n    else:\n        result = func(*args, **kwargs)\n\n    return result\n</code></pre>"},{"location":"utils/#chatflow.utils.a_read_input_with_timeout","title":"<code>a_read_input_with_timeout(timeout=None)</code>  <code>async</code>","text":"<p>Reads input from the user with an optional timeout.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>The timeout value in seconds. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The input message from the user if received within the timeout, None otherwise.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>async def a_read_input_with_timeout(timeout=None):\n    \"\"\"Reads input from the user with an optional timeout.\n\n    Args:\n        timeout (int, optional): The timeout value in seconds. Defaults to None.\n\n    Returns:\n        str: The input message from the user if received within the timeout, None otherwise.\n    \"\"\"\n    if timeout is None:\n        return input()\n    else:\n        timeout_task = asyncio.create_task(timeout_checker(timeout))\n        input_task = asyncio.create_task(aioconsole.ainput())\n        done, pending = await asyncio.wait(\n            {timeout_task, input_task}, return_when=asyncio.FIRST_COMPLETED\n        )\n\n        if input_task in done:\n            message = input_task.result()\n            timeout_task.cancel()\n            return message\n        else:\n            input_task.cancel()\n            return None\n</code></pre>"},{"location":"utils/#chatflow.utils.aprint","title":"<code>aprint(*args, **kwargs)</code>  <code>async</code>","text":"<p>Prints the given arguments to the console.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>The arguments to be printed.</p> <code>()</code> <code>**kwargs</code> <p>The keyword arguments to be printed.</p> <code>{}</code> Source code in <code>chatflow\\utils.py</code> <pre><code>async def aprint(*args, **kwargs):\n    \"\"\"Prints the given arguments to the console.\n\n    Args:\n        *args: The arguments to be printed.\n        **kwargs: The keyword arguments to be printed.\n    \"\"\"\n    print(*args, **kwargs, flush=True)\n</code></pre>"},{"location":"utils/#chatflow.utils.call_function","title":"<code>call_function(func, *args, **kwargs)</code>","text":"<p>Call a function and return the result.</p> <p>This function takes a function <code>func</code> as input along with any additional arguments and keyword arguments. It checks if the function is a coroutine function and runs it using asyncio if it is. Otherwise, it simply calls the function and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to be called.</p> required <code>*args</code> <p>Additional positional arguments to be passed to the function.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of calling the function.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>def call_function(func, *args, **kwargs):\n    \"\"\"Call a function and return the result.\n\n    This function takes a function `func` as input along with any additional\n    arguments and keyword arguments. It checks if the function is a coroutine\n    function and runs it using asyncio if it is. Otherwise, it simply calls\n    the function and returns the result.\n\n    Args:\n        func (callable): The function to be called.\n        *args: Additional positional arguments to be passed to the function.\n        **kwargs: Additional keyword arguments to be passed to the function.\n\n    Returns:\n        Any: The result of calling the function.\n\n    \"\"\"\n    if inspect.iscoroutinefunction(func):\n        result = asyncio.run(func(*args, **kwargs))\n    else:\n        result = func(*args, **kwargs)\n    return result\n</code></pre>"},{"location":"utils/#chatflow.utils.format_string","title":"<code>format_string(input_str, context)</code>","text":"<p>Replace variables enclosed in curly braces with their corresponding values.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string containing variables to be replaced.</p> required <code>context</code> <code>Context</code> <p>The context dictionary containing variable-value mappings.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The input string with variables replaced by their values.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>def format_string(input_str: str, context):\n    \"\"\"Replace variables enclosed in curly braces with their corresponding values.\n\n    Args:\n        input_str (str): The input string containing variables to be replaced.\n        context (Context): The context dictionary containing variable-value mappings.\n\n    Returns:\n        (str): The input string with variables replaced by their values.\n    \"\"\"\n    start_index = input_str.find(\"{\")\n    end_index = input_str.find(\"}\")\n\n    while start_index != -1 and end_index != -1:\n        if start_index &gt; 0 and input_str[start_index - 1] == \"\\\\\":\n            start_index = input_str.find(\"{\", start_index + 1)\n            end_index = input_str.find(\"}\", end_index + 1)\n            continue\n\n        variable_name = input_str[start_index + 1: end_index]\n        value = context.get_variable(variable_name)\n        if value is not None:\n            input_str = (\n                    input_str[:start_index] + str(value) + input_str[end_index + 1:]\n            )\n\n        start_index = input_str.find(\"{\", start_index + 1)\n        end_index = input_str.find(\"}\", end_index + 1)\n\n    input_str = input_str.replace(\"\\\\{\", \"{\").replace(\"\\\\}\", \"}\")\n\n    return input_str\n</code></pre>"},{"location":"utils/#chatflow.utils.read_input_with_timeout","title":"<code>read_input_with_timeout(timeout=None)</code>","text":"<p>Reads user input with an optional timeout.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>The timeout value in seconds. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The user input if received within the timeout, None otherwise.</p> Source code in <code>chatflow\\utils.py</code> <pre><code>def read_input_with_timeout(timeout=None):\n    \"\"\"Reads user input with an optional timeout.\n\n    Args:\n        timeout (float, optional): The timeout value in seconds. Defaults to None.\n\n    Returns:\n        str: The user input if received within the timeout, None otherwise.\n    \"\"\"\n    try:\n        if timeout is None:\n            message = input()\n        else:\n            message = inputimeout(prompt=\"\", timeout=timeout)\n        return message\n    except TimeoutOccurred:\n        return None\n</code></pre>"}]}